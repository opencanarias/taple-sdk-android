// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

@file:Suppress("NAME_SHADOWING")

package com.opencanarias.taple.ffi;

// Common helper code.
//
// Ideally this would live in a separate .kt file where it can be unittested etc
// in isolation, and perhaps even published as a re-useable package.
//
// However, it's important that the detils of how this helper code works (e.g. the
// way that different builtin types are passed across the FFI) exactly match what's
// expected by the Rust code on the other side of the interface. In practice right
// now that means coming from the exact some version of `uniffi` that was used to
// compile the Rust component. The easiest way to ensure this is to bundle the Kotlin
// helpers directly inline like we're doing here.

import com.sun.jna.Library
import com.sun.jna.Native
import com.sun.jna.Pointer
import com.sun.jna.Structure
import com.sun.jna.ptr.ByReference
import java.nio.ByteBuffer
import java.nio.ByteOrder
import java.util.concurrent.atomic.AtomicBoolean
import java.util.concurrent.atomic.AtomicLong
import java.util.concurrent.locks.ReentrantLock
import kotlin.concurrent.withLock

// This is a helper for safely working with byte buffers returned from the Rust code.
// A rust-owned buffer is represented by its capacity, its current length, and a
// pointer to the underlying data.

@Structure.FieldOrder("capacity", "len", "data")
open class RustBuffer : Structure() {
    @JvmField var capacity: Int = 0
    @JvmField var len: Int = 0
    @JvmField var data: Pointer? = null

    class ByValue : RustBuffer(), Structure.ByValue
    class ByReference : RustBuffer(), Structure.ByReference

    companion object {
        internal fun alloc(size: Int = 0) = rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_taple_ffi_b33d_rustbuffer_alloc(size, status).also {
                if(it.data == null) {
                   throw RuntimeException("RustBuffer.alloc() returned null data pointer (size=${size})")
               }
            }
        }

        internal fun free(buf: RustBuffer.ByValue) = rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_taple_ffi_b33d_rustbuffer_free(buf, status)
        }
    }

    @Suppress("TooGenericExceptionThrown")
    fun asByteBuffer() =
        this.data?.getByteBuffer(0, this.len.toLong())?.also {
            it.order(ByteOrder.BIG_ENDIAN)
        }
}

/**
 * The equivalent of the `*mut RustBuffer` type.
 * Required for callbacks taking in an out pointer.
 *
 * Size is the sum of all values in the struct.
 */
class RustBufferByReference : ByReference(16) {
    /**
     * Set the pointed-to `RustBuffer` to the given value.
     */
    fun setValue(value: RustBuffer.ByValue) {
        // NOTE: The offsets are as they are in the C-like struct.
        val pointer = getPointer()
        pointer.setInt(0, value.capacity)
        pointer.setInt(4, value.len)
        pointer.setPointer(8, value.data)
    }
}

// This is a helper for safely passing byte references into the rust code.
// It's not actually used at the moment, because there aren't many things that you
// can take a direct pointer to in the JVM, and if we're going to copy something
// then we might as well copy it into a `RustBuffer`. But it's here for API
// completeness.

@Structure.FieldOrder("len", "data")
open class ForeignBytes : Structure() {
    @JvmField var len: Int = 0
    @JvmField var data: Pointer? = null

    class ByValue : ForeignBytes(), Structure.ByValue
}
// The FfiConverter interface handles converter types to and from the FFI
//
// All implementing objects should be public to support external types.  When a
// type is external we need to import it's FfiConverter.
public interface FfiConverter<KotlinType, FfiType> {
    // Convert an FFI type to a Kotlin type
    fun lift(value: FfiType): KotlinType

    // Convert an Kotlin type to an FFI type
    fun lower(value: KotlinType): FfiType

    // Read a Kotlin type from a `ByteBuffer`
    fun read(buf: ByteBuffer): KotlinType

    // Calculate bytes to allocate when creating a `RustBuffer`
    //
    // This must return at least as many bytes as the write() function will
    // write. It can return more bytes than needed, for example when writing
    // Strings we can't know the exact bytes needed until we the UTF-8
    // encoding, so we pessimistically allocate the largest size possible (3
    // bytes per codepoint).  Allocating extra bytes is not really a big deal
    // because the `RustBuffer` is short-lived.
    fun allocationSize(value: KotlinType): Int

    // Write a Kotlin type to a `ByteBuffer`
    fun write(value: KotlinType, buf: ByteBuffer)

    // Lower a value into a `RustBuffer`
    //
    // This method lowers a value into a `RustBuffer` rather than the normal
    // FfiType.  It's used by the callback interface code.  Callback interface
    // returns are always serialized into a `RustBuffer` regardless of their
    // normal FFI type.
    fun lowerIntoRustBuffer(value: KotlinType): RustBuffer.ByValue {
        val rbuf = RustBuffer.alloc(allocationSize(value))
        try {
            val bbuf = rbuf.data!!.getByteBuffer(0, rbuf.capacity.toLong()).also {
                it.order(ByteOrder.BIG_ENDIAN)
            }
            write(value, bbuf)
            rbuf.writeField("len", bbuf.position())
            return rbuf
        } catch (e: Throwable) {
            RustBuffer.free(rbuf)
            throw e
        }
    }

    // Lift a value from a `RustBuffer`.
    //
    // This here mostly because of the symmetry with `lowerIntoRustBuffer()`.
    // It's currently only used by the `FfiConverterRustBuffer` class below.
    fun liftFromRustBuffer(rbuf: RustBuffer.ByValue): KotlinType {
        val byteBuf = rbuf.asByteBuffer()!!
        try {
           val item = read(byteBuf)
           if (byteBuf.hasRemaining()) {
               throw RuntimeException("junk remaining in buffer after lifting, something is very wrong!!")
           }
           return item
        } finally {
            RustBuffer.free(rbuf)
        }
    }
}

// FfiConverter that uses `RustBuffer` as the FfiType
public interface FfiConverterRustBuffer<KotlinType>: FfiConverter<KotlinType, RustBuffer.ByValue> {
    override fun lift(value: RustBuffer.ByValue) = liftFromRustBuffer(value)
    override fun lower(value: KotlinType) = lowerIntoRustBuffer(value)
}
// A handful of classes and functions to support the generated data structures.
// This would be a good candidate for isolating in its own ffi-support lib.
// Error runtime.
@Structure.FieldOrder("code", "error_buf")
internal open class RustCallStatus : Structure() {
    @JvmField var code: Int = 0
    @JvmField var error_buf: RustBuffer.ByValue = RustBuffer.ByValue()

    fun isSuccess(): Boolean {
        return code == 0
    }

    fun isError(): Boolean {
        return code == 1
    }

    fun isPanic(): Boolean {
        return code == 2
    }
}

class InternalException(message: String) : Exception(message)

// Each top-level error class has a companion object that can lift the error from the call status's rust buffer
interface CallStatusErrorHandler<E> {
    fun lift(error_buf: RustBuffer.ByValue): E;
}

// Helpers for calling Rust
// In practice we usually need to be synchronized to call this safely, so it doesn't
// synchronize itself

// Call a rust function that returns a Result<>.  Pass in the Error class companion that corresponds to the Err
private inline fun <U, E: Exception> rustCallWithError(errorHandler: CallStatusErrorHandler<E>, callback: (RustCallStatus) -> U): U {
    var status = RustCallStatus();
    val return_value = callback(status)
    if (status.isSuccess()) {
        return return_value
    } else if (status.isError()) {
        throw errorHandler.lift(status.error_buf)
    } else if (status.isPanic()) {
        // when the rust code sees a panic, it tries to construct a rustbuffer
        // with the message.  but if that code panics, then it just sends back
        // an empty buffer.
        if (status.error_buf.len > 0) {
            throw InternalException(FfiConverterString.lift(status.error_buf))
        } else {
            throw InternalException("Rust panic")
        }
    } else {
        throw InternalException("Unknown rust call status: $status.code")
    }
}

// CallStatusErrorHandler implementation for times when we don't expect a CALL_ERROR
object NullCallStatusErrorHandler: CallStatusErrorHandler<InternalException> {
    override fun lift(error_buf: RustBuffer.ByValue): InternalException {
        RustBuffer.free(error_buf)
        return InternalException("Unexpected CALL_ERROR")
    }
}

// Call a rust function that returns a plain value
private inline fun <U> rustCall(callback: (RustCallStatus) -> U): U {
    return rustCallWithError(NullCallStatusErrorHandler, callback);
}

// Contains loading, initialization code,
// and the FFI Function declarations in a com.sun.jna.Library.
@Synchronized
private fun findLibraryName(componentName: String): String {
    val libOverride = System.getProperty("uniffi.component.$componentName.libraryOverride")
    if (libOverride != null) {
        return libOverride
    }
    return "taple_ffi"
}

private inline fun <reified Lib : Library> loadIndirect(
    componentName: String
): Lib {
    return Native.load<Lib>(findLibraryName(componentName), Lib::class.java)
}

// A JNA Library to expose the extern-C FFI definitions.
// This is an implementation detail which will be called internally by the public API.

internal interface _UniFFILib : Library {
    companion object {
        internal val INSTANCE: _UniFFILib by lazy {
            loadIndirect<_UniFFILib>(componentName = "taple_ffi")
            .also { lib: _UniFFILib ->
                FfiConverterTypeDatabaseManagerInterface.register(lib)
                FfiConverterTypeDbCollectionInterface.register(lib)
                FfiConverterTypeDbCollectionIteratorInterface.register(lib)
                FfiConverterTypeNotificationHandlerInterface.register(lib)
                }
            
        }
    }

    fun ffi_taple_ffi_b33d_UserSubject_object_free(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Unit

    fun taple_ffi_b33d_UserSubject_end_life_cicle(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun taple_ffi_b33d_UserSubject_new_fact_event(`ptr`: Pointer,`payload`: RustBuffer.ByValue,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun taple_ffi_b33d_UserSubject_refresh(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Unit

    fun taple_ffi_b33d_UserSubject_external_invokation(`ptr`: Pointer,`event`: RustBuffer.ByValue,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun taple_ffi_b33d_UserSubject_to_governance(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun taple_ffi_b33d_UserSubject_get_subject_id(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun taple_ffi_b33d_UserSubject_get_governance_id(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun taple_ffi_b33d_UserSubject_get_sn(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun taple_ffi_b33d_UserSubject_get_public_key(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun taple_ffi_b33d_UserSubject_get_namespace(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun taple_ffi_b33d_UserSubject_get_schema_id(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun taple_ffi_b33d_UserSubject_get_owner(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun taple_ffi_b33d_UserSubject_get_creator(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun taple_ffi_b33d_UserSubject_get_properties(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun taple_ffi_b33d_UserSubject_get_subject_request(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun taple_ffi_b33d_UserSubject_get_is_active(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun ffi_taple_ffi_b33d_UserGovernance_object_free(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Unit

    fun taple_ffi_b33d_UserGovernance_new(`subject`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun taple_ffi_b33d_UserGovernance_get_members(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun taple_ffi_b33d_UserGovernance_get_schemas(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun taple_ffi_b33d_UserGovernance_get_policies(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun taple_ffi_b33d_UserGovernance_get_roles(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun taple_ffi_b33d_UserGovernance_refresh(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Unit

    fun taple_ffi_b33d_UserGovernance_get_subject_id(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun taple_ffi_b33d_UserGovernance_get_governance_id(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun taple_ffi_b33d_UserGovernance_get_sn(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Long

    fun taple_ffi_b33d_UserGovernance_get_public_key(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun taple_ffi_b33d_UserGovernance_get_namespace(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun taple_ffi_b33d_UserGovernance_get_schema_id(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun taple_ffi_b33d_UserGovernance_get_owner(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun taple_ffi_b33d_UserGovernance_get_creator(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun taple_ffi_b33d_UserGovernance_get_properties(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun taple_ffi_b33d_UserGovernance_get_is_active(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Byte

    fun ffi_taple_ffi_b33d_TapleAPI_object_free(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Unit

    fun taple_ffi_b33d_TapleAPI_get_request(`ptr`: Pointer,`requestId`: RustBuffer.ByValue,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun taple_ffi_b33d_TapleAPI_external_request(`ptr`: Pointer,`eventRequest`: RustBuffer.ByValue,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun taple_ffi_b33d_TapleAPI_get_subject(`ptr`: Pointer,`subjectId`: RustBuffer.ByValue,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun taple_ffi_b33d_TapleAPI_add_preauthorize_subject(`ptr`: Pointer,`subjectId`: RustBuffer.ByValue,`providers`: RustBuffer.ByValue,
    _uniffi_out_err: RustCallStatus
    ): Unit

    fun taple_ffi_b33d_TapleAPI_add_keys(`ptr`: Pointer,`derivator`: RustBuffer.ByValue,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun taple_ffi_b33d_TapleAPI_get_governances(`ptr`: Pointer,`namespace`: RustBuffer.ByValue,`from`: RustBuffer.ByValue,`quantity`: RustBuffer.ByValue,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun taple_ffi_b33d_TapleAPI_get_subjects(`ptr`: Pointer,`namespace`: RustBuffer.ByValue,`from`: RustBuffer.ByValue,`quantity`: RustBuffer.ByValue,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun taple_ffi_b33d_TapleAPI_get_subjects_by_governance(`ptr`: Pointer,`governanceId`: RustBuffer.ByValue,`from`: RustBuffer.ByValue,`quantity`: RustBuffer.ByValue,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun taple_ffi_b33d_TapleAPI_get_events(`ptr`: Pointer,`subjectId`: RustBuffer.ByValue,`from`: RustBuffer.ByValue,`quantity`: RustBuffer.ByValue,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun taple_ffi_b33d_TapleAPI_get_event(`ptr`: Pointer,`subjectId`: RustBuffer.ByValue,`sn`: Long,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun taple_ffi_b33d_TapleAPI_get_all_allowed_subjects_and_providers(`ptr`: Pointer,`from`: RustBuffer.ByValue,`quantity`: RustBuffer.ByValue,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun taple_ffi_b33d_TapleAPI_get_validation_proof(`ptr`: Pointer,`subjectId`: RustBuffer.ByValue,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun taple_ffi_b33d_TapleAPI_sign_event_request(`ptr`: Pointer,`eventRequest`: RustBuffer.ByValue,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun ffi_taple_ffi_b33d_TapleNode_object_free(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Unit

    fun taple_ffi_b33d_TapleNode_get_api(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun taple_ffi_b33d_TapleNode_get_shutdown_handler(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun taple_ffi_b33d_TapleNode_receive_blocking(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun taple_ffi_b33d_TapleNode_drop_notifications(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Unit

    fun taple_ffi_b33d_TapleNode_handle_notifications(`ptr`: Pointer,`handler`: Long,
    _uniffi_out_err: RustCallStatus
    ): Unit

    fun taple_ffi_b33d_TapleNode_get_subject_builder(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun taple_ffi_b33d_TapleNode_shutdown_gracefully(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Unit

    fun ffi_taple_ffi_b33d_SubjectBuilder_object_free(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Unit

    fun taple_ffi_b33d_SubjectBuilder_with_name(`ptr`: Pointer,`name`: RustBuffer.ByValue,
    _uniffi_out_err: RustCallStatus
    ): Unit

    fun taple_ffi_b33d_SubjectBuilder_with_namespace(`ptr`: Pointer,`namespace`: RustBuffer.ByValue,
    _uniffi_out_err: RustCallStatus
    ): Unit

    fun taple_ffi_b33d_SubjectBuilder_build(`ptr`: Pointer,`governanceId`: RustBuffer.ByValue,`schemaId`: RustBuffer.ByValue,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun ffi_taple_ffi_b33d_ShutdownSignal_object_free(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Unit

    fun taple_ffi_b33d_ShutdownSignal_shutdown(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Unit

    fun ffi_taple_ffi_b33d_DbCollectionIteratorInterface_init_callback(`callbackStub`: ForeignCallback,
    _uniffi_out_err: RustCallStatus
    ): Unit

    fun ffi_taple_ffi_b33d_DbCollectionInterface_init_callback(`callbackStub`: ForeignCallback,
    _uniffi_out_err: RustCallStatus
    ): Unit

    fun ffi_taple_ffi_b33d_DatabaseManagerInterface_init_callback(`callbackStub`: ForeignCallback,
    _uniffi_out_err: RustCallStatus
    ): Unit

    fun ffi_taple_ffi_b33d_NotificationHandlerInterface_init_callback(`callbackStub`: ForeignCallback,
    _uniffi_out_err: RustCallStatus
    ): Unit

    fun taple_ffi_b33d_start(`manager`: Long,`settings`: RustBuffer.ByValue,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun taple_ffi_b33d_generate_key(`keyDerivator`: RustBuffer.ByValue,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun ffi_taple_ffi_b33d_rustbuffer_alloc(`size`: Int,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun ffi_taple_ffi_b33d_rustbuffer_from_bytes(`bytes`: ForeignBytes.ByValue,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun ffi_taple_ffi_b33d_rustbuffer_free(`buf`: RustBuffer.ByValue,
    _uniffi_out_err: RustCallStatus
    ): Unit

    fun ffi_taple_ffi_b33d_rustbuffer_reserve(`buf`: RustBuffer.ByValue,`additional`: Int,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    
}

// Public interface members begin here.


public object FfiConverterUByte: FfiConverter<UByte, Byte> {
    override fun lift(value: Byte): UByte {
        return value.toUByte()
    }

    override fun read(buf: ByteBuffer): UByte {
        return lift(buf.get())
    }

    override fun lower(value: UByte): Byte {
        return value.toByte()
    }

    override fun allocationSize(value: UByte) = 1

    override fun write(value: UByte, buf: ByteBuffer) {
        buf.put(value.toByte())
    }
}

public object FfiConverterULong: FfiConverter<ULong, Long> {
    override fun lift(value: Long): ULong {
        return value.toULong()
    }

    override fun read(buf: ByteBuffer): ULong {
        return lift(buf.getLong())
    }

    override fun lower(value: ULong): Long {
        return value.toLong()
    }

    override fun allocationSize(value: ULong) = 8

    override fun write(value: ULong, buf: ByteBuffer) {
        buf.putLong(value.toLong())
    }
}

public object FfiConverterLong: FfiConverter<Long, Long> {
    override fun lift(value: Long): Long {
        return value
    }

    override fun read(buf: ByteBuffer): Long {
        return buf.getLong()
    }

    override fun lower(value: Long): Long {
        return value
    }

    override fun allocationSize(value: Long) = 8

    override fun write(value: Long, buf: ByteBuffer) {
        buf.putLong(value)
    }
}

public object FfiConverterDouble: FfiConverter<Double, Double> {
    override fun lift(value: Double): Double {
        return value
    }

    override fun read(buf: ByteBuffer): Double {
        return buf.getDouble()
    }

    override fun lower(value: Double): Double {
        return value
    }

    override fun allocationSize(value: Double) = 8

    override fun write(value: Double, buf: ByteBuffer) {
        buf.putDouble(value)
    }
}

public object FfiConverterBoolean: FfiConverter<Boolean, Byte> {
    override fun lift(value: Byte): Boolean {
        return value.toInt() != 0
    }

    override fun read(buf: ByteBuffer): Boolean {
        return lift(buf.get())
    }

    override fun lower(value: Boolean): Byte {
        return if (value) 1.toByte() else 0.toByte()
    }

    override fun allocationSize(value: Boolean) = 1

    override fun write(value: Boolean, buf: ByteBuffer) {
        buf.put(lower(value))
    }
}

public object FfiConverterString: FfiConverter<String, RustBuffer.ByValue> {
    // Note: we don't inherit from FfiConverterRustBuffer, because we use a
    // special encoding when lowering/lifting.  We can use `RustBuffer.len` to
    // store our length and avoid writing it out to the buffer.
    override fun lift(value: RustBuffer.ByValue): String {
        try {
            val byteArr = ByteArray(value.len)
            value.asByteBuffer()!!.get(byteArr)
            return byteArr.toString(Charsets.UTF_8)
        } finally {
            RustBuffer.free(value)
        }
    }

    override fun read(buf: ByteBuffer): String {
        val len = buf.getInt()
        val byteArr = ByteArray(len)
        buf.get(byteArr)
        return byteArr.toString(Charsets.UTF_8)
    }

    override fun lower(value: String): RustBuffer.ByValue {
        val byteArr = value.toByteArray(Charsets.UTF_8)
        // Ideally we'd pass these bytes to `ffi_bytebuffer_from_bytes`, but doing so would require us
        // to copy them into a JNA `Memory`. So we might as well directly copy them into a `RustBuffer`.
        val rbuf = RustBuffer.alloc(byteArr.size)
        rbuf.asByteBuffer()!!.put(byteArr)
        return rbuf
    }

    // We aren't sure exactly how many bytes our string will be once it's UTF-8
    // encoded.  Allocate 3 bytes per unicode codepoint which will always be
    // enough.
    override fun allocationSize(value: String): Int {
        val sizeForLength = 4
        val sizeForString = value.length * 3
        return sizeForLength + sizeForString
    }

    override fun write(value: String, buf: ByteBuffer) {
        val byteArr = value.toByteArray(Charsets.UTF_8)
        buf.putInt(byteArr.size)
        buf.put(byteArr)
    }
}


// Interface implemented by anything that can contain an object reference.
//
// Such types expose a `destroy()` method that must be called to cleanly
// dispose of the contained objects. Failure to call this method may result
// in memory leaks.
//
// The easiest way to ensure this method is called is to use the `.use`
// helper method to execute a block and destroy the object at the end.
interface Disposable {
    fun destroy()
    companion object {
        fun destroy(vararg args: Any?) {
            args.filterIsInstance<Disposable>()
                .forEach(Disposable::destroy)
        }
    }
}

inline fun <T : Disposable?, R> T.use(block: (T) -> R) =
    try {
        block(this)
    } finally {
        try {
            // N.B. our implementation is on the nullable type `Disposable?`.
            this?.destroy()
        } catch (e: Throwable) {
            // swallow
        }
    }

// The base class for all UniFFI Object types.
//
// This class provides core operations for working with the Rust `Arc<T>` pointer to
// the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// the Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each `FFIObject` instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an `FFIObject` is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an `FFIObject` instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so will
//     leak the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each `FFIObject` an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// In the future we may be able to replace some of this with automatic finalization logic, such as using
// the new "Cleaner" functionaility in Java 9. The above scheme has been designed to work even if `destroy` is
// invoked by garbage-collection machinery rather than by calling code (which by the way, it's apparently also
// possible for the JVM to finalize an object while there is an in-flight call to one of its methods [1],
// so there would still be some complexity here).
//
// Sigh...all of this for want of a robust finalization mechanism.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//
abstract class FFIObject(
    protected val pointer: Pointer
): Disposable, AutoCloseable {

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    open protected fun freeRustArcPtr() {
        // To be overridden in subclasses.
    }

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                this.freeRustArcPtr()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.pointer)
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                this.freeRustArcPtr()
            }
        }
    }
}

public interface ShutdownSignalInterface {
    
    @Throws(ShutdownException::class)
    fun `shutdown`()
    
}

class ShutdownSignal(
    pointer: Pointer
) : FFIObject(pointer), ShutdownSignalInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    override protected fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_taple_ffi_b33d_ShutdownSignal_object_free(this.pointer, status)
        }
    }

    
    @Throws(ShutdownException::class)override fun `shutdown`() =
        callWithPointer {
    rustCallWithError(ShutdownException) { _status ->
    _UniFFILib.INSTANCE.taple_ffi_b33d_ShutdownSignal_shutdown(it,  _status)
}
        }
    
    

    
}

public object FfiConverterTypeShutdownSignal: FfiConverter<ShutdownSignal, Pointer> {
    override fun lower(value: ShutdownSignal): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ShutdownSignal {
        return ShutdownSignal(value)
    }

    override fun read(buf: ByteBuffer): ShutdownSignal {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ShutdownSignal) = 8

    override fun write(value: ShutdownSignal, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}




public interface SubjectBuilderInterface {
    
    @Throws(TapleException::class)
    fun `withName`(`name`: String)
    
    @Throws(TapleException::class)
    fun `withNamespace`(`namespace`: String)
    
    @Throws(TapleException::class)
    fun `build`(`governanceId`: String, `schemaId`: String): UserSubject
    
}

class SubjectBuilder(
    pointer: Pointer
) : FFIObject(pointer), SubjectBuilderInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    override protected fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_taple_ffi_b33d_SubjectBuilder_object_free(this.pointer, status)
        }
    }

    
    @Throws(TapleException::class)override fun `withName`(`name`: String) =
        callWithPointer {
    rustCallWithError(TapleException) { _status ->
    _UniFFILib.INSTANCE.taple_ffi_b33d_SubjectBuilder_with_name(it, FfiConverterString.lower(`name`),  _status)
}
        }
    
    
    @Throws(TapleException::class)override fun `withNamespace`(`namespace`: String) =
        callWithPointer {
    rustCallWithError(TapleException) { _status ->
    _UniFFILib.INSTANCE.taple_ffi_b33d_SubjectBuilder_with_namespace(it, FfiConverterString.lower(`namespace`),  _status)
}
        }
    
    
    @Throws(TapleException::class)override fun `build`(`governanceId`: String, `schemaId`: String): UserSubject =
        callWithPointer {
    rustCallWithError(TapleException) { _status ->
    _UniFFILib.INSTANCE.taple_ffi_b33d_SubjectBuilder_build(it, FfiConverterString.lower(`governanceId`), FfiConverterString.lower(`schemaId`),  _status)
}
        }.let {
            FfiConverterTypeUserSubject.lift(it)
        }
    

    
}

public object FfiConverterTypeSubjectBuilder: FfiConverter<SubjectBuilder, Pointer> {
    override fun lower(value: SubjectBuilder): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): SubjectBuilder {
        return SubjectBuilder(value)
    }

    override fun read(buf: ByteBuffer): SubjectBuilder {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: SubjectBuilder) = 8

    override fun write(value: SubjectBuilder, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}




public interface TapleApiInterface {
    
    @Throws(TapleException::class)
    fun `getRequest`(`requestId`: String): TapleRequest
    
    @Throws(TapleException::class)
    fun `externalRequest`(`eventRequest`: TapleSignedEventRequest): String
    
    @Throws(TapleException::class)
    fun `getSubject`(`subjectId`: String): UserSubject
    
    @Throws(TapleException::class)
    fun `addPreauthorizeSubject`(`subjectId`: String, `providers`: List<String>)
    
    @Throws(TapleException::class)
    fun `addKeys`(`derivator`: String): String
    
    @Throws(TapleException::class)
    fun `getGovernances`(`namespace`: String, `from`: String?, `quantity`: Long?): List<UserSubject>
    
    @Throws(TapleException::class)
    fun `getSubjects`(`namespace`: String, `from`: String?, `quantity`: Long?): List<UserSubject>
    
    @Throws(TapleException::class)
    fun `getSubjectsByGovernance`(`governanceId`: String, `from`: String?, `quantity`: Long?): List<UserSubject>
    
    @Throws(TapleException::class)
    fun `getEvents`(`subjectId`: String, `from`: Long?, `quantity`: Long?): List<TapleSignedEvent>
    
    @Throws(TapleException::class)
    fun `getEvent`(`subjectId`: String, `sn`: ULong): TapleSignedEvent
    
    @Throws(TapleException::class)
    fun `getAllAllowedSubjectsAndProviders`(`from`: String?, `quantity`: Long?): List<SubjectAndProviders>
    
    @Throws(TapleException::class)
    fun `getValidationProof`(`subjectId`: String): ValidationProofAndSignatures
    
    @Throws(TapleException::class)
    fun `signEventRequest`(`eventRequest`: EventRequestType): TapleSignature
    
}

class TapleApi(
    pointer: Pointer
) : FFIObject(pointer), TapleApiInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    override protected fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_taple_ffi_b33d_TapleAPI_object_free(this.pointer, status)
        }
    }

    
    @Throws(TapleException::class)override fun `getRequest`(`requestId`: String): TapleRequest =
        callWithPointer {
    rustCallWithError(TapleException) { _status ->
    _UniFFILib.INSTANCE.taple_ffi_b33d_TapleAPI_get_request(it, FfiConverterString.lower(`requestId`),  _status)
}
        }.let {
            FfiConverterTypeTapleRequest.lift(it)
        }
    
    @Throws(TapleException::class)override fun `externalRequest`(`eventRequest`: TapleSignedEventRequest): String =
        callWithPointer {
    rustCallWithError(TapleException) { _status ->
    _UniFFILib.INSTANCE.taple_ffi_b33d_TapleAPI_external_request(it, FfiConverterTypeTapleSignedEventRequest.lower(`eventRequest`),  _status)
}
        }.let {
            FfiConverterString.lift(it)
        }
    
    @Throws(TapleException::class)override fun `getSubject`(`subjectId`: String): UserSubject =
        callWithPointer {
    rustCallWithError(TapleException) { _status ->
    _UniFFILib.INSTANCE.taple_ffi_b33d_TapleAPI_get_subject(it, FfiConverterString.lower(`subjectId`),  _status)
}
        }.let {
            FfiConverterTypeUserSubject.lift(it)
        }
    
    @Throws(TapleException::class)override fun `addPreauthorizeSubject`(`subjectId`: String, `providers`: List<String>) =
        callWithPointer {
    rustCallWithError(TapleException) { _status ->
    _UniFFILib.INSTANCE.taple_ffi_b33d_TapleAPI_add_preauthorize_subject(it, FfiConverterString.lower(`subjectId`), FfiConverterSequenceString.lower(`providers`),  _status)
}
        }
    
    
    @Throws(TapleException::class)override fun `addKeys`(`derivator`: String): String =
        callWithPointer {
    rustCallWithError(TapleException) { _status ->
    _UniFFILib.INSTANCE.taple_ffi_b33d_TapleAPI_add_keys(it, FfiConverterString.lower(`derivator`),  _status)
}
        }.let {
            FfiConverterString.lift(it)
        }
    
    @Throws(TapleException::class)override fun `getGovernances`(`namespace`: String, `from`: String?, `quantity`: Long?): List<UserSubject> =
        callWithPointer {
    rustCallWithError(TapleException) { _status ->
    _UniFFILib.INSTANCE.taple_ffi_b33d_TapleAPI_get_governances(it, FfiConverterString.lower(`namespace`), FfiConverterOptionalString.lower(`from`), FfiConverterOptionalLong.lower(`quantity`),  _status)
}
        }.let {
            FfiConverterSequenceTypeUserSubject.lift(it)
        }
    
    @Throws(TapleException::class)override fun `getSubjects`(`namespace`: String, `from`: String?, `quantity`: Long?): List<UserSubject> =
        callWithPointer {
    rustCallWithError(TapleException) { _status ->
    _UniFFILib.INSTANCE.taple_ffi_b33d_TapleAPI_get_subjects(it, FfiConverterString.lower(`namespace`), FfiConverterOptionalString.lower(`from`), FfiConverterOptionalLong.lower(`quantity`),  _status)
}
        }.let {
            FfiConverterSequenceTypeUserSubject.lift(it)
        }
    
    @Throws(TapleException::class)override fun `getSubjectsByGovernance`(`governanceId`: String, `from`: String?, `quantity`: Long?): List<UserSubject> =
        callWithPointer {
    rustCallWithError(TapleException) { _status ->
    _UniFFILib.INSTANCE.taple_ffi_b33d_TapleAPI_get_subjects_by_governance(it, FfiConverterString.lower(`governanceId`), FfiConverterOptionalString.lower(`from`), FfiConverterOptionalLong.lower(`quantity`),  _status)
}
        }.let {
            FfiConverterSequenceTypeUserSubject.lift(it)
        }
    
    @Throws(TapleException::class)override fun `getEvents`(`subjectId`: String, `from`: Long?, `quantity`: Long?): List<TapleSignedEvent> =
        callWithPointer {
    rustCallWithError(TapleException) { _status ->
    _UniFFILib.INSTANCE.taple_ffi_b33d_TapleAPI_get_events(it, FfiConverterString.lower(`subjectId`), FfiConverterOptionalLong.lower(`from`), FfiConverterOptionalLong.lower(`quantity`),  _status)
}
        }.let {
            FfiConverterSequenceTypeTapleSignedEvent.lift(it)
        }
    
    @Throws(TapleException::class)override fun `getEvent`(`subjectId`: String, `sn`: ULong): TapleSignedEvent =
        callWithPointer {
    rustCallWithError(TapleException) { _status ->
    _UniFFILib.INSTANCE.taple_ffi_b33d_TapleAPI_get_event(it, FfiConverterString.lower(`subjectId`), FfiConverterULong.lower(`sn`),  _status)
}
        }.let {
            FfiConverterTypeTapleSignedEvent.lift(it)
        }
    
    @Throws(TapleException::class)override fun `getAllAllowedSubjectsAndProviders`(`from`: String?, `quantity`: Long?): List<SubjectAndProviders> =
        callWithPointer {
    rustCallWithError(TapleException) { _status ->
    _UniFFILib.INSTANCE.taple_ffi_b33d_TapleAPI_get_all_allowed_subjects_and_providers(it, FfiConverterOptionalString.lower(`from`), FfiConverterOptionalLong.lower(`quantity`),  _status)
}
        }.let {
            FfiConverterSequenceTypeSubjectAndProviders.lift(it)
        }
    
    @Throws(TapleException::class)override fun `getValidationProof`(`subjectId`: String): ValidationProofAndSignatures =
        callWithPointer {
    rustCallWithError(TapleException) { _status ->
    _UniFFILib.INSTANCE.taple_ffi_b33d_TapleAPI_get_validation_proof(it, FfiConverterString.lower(`subjectId`),  _status)
}
        }.let {
            FfiConverterTypeValidationProofAndSignatures.lift(it)
        }
    
    @Throws(TapleException::class)override fun `signEventRequest`(`eventRequest`: EventRequestType): TapleSignature =
        callWithPointer {
    rustCallWithError(TapleException) { _status ->
    _UniFFILib.INSTANCE.taple_ffi_b33d_TapleAPI_sign_event_request(it, FfiConverterTypeEventRequestType.lower(`eventRequest`),  _status)
}
        }.let {
            FfiConverterTypeTapleSignature.lift(it)
        }
    

    
}

public object FfiConverterTypeTapleApi: FfiConverter<TapleApi, Pointer> {
    override fun lower(value: TapleApi): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): TapleApi {
        return TapleApi(value)
    }

    override fun read(buf: ByteBuffer): TapleApi {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: TapleApi) = 8

    override fun write(value: TapleApi, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}




public interface TapleNodeInterface {
    
    fun `getApi`(): TapleApi
    
    fun `getShutdownHandler`(): ShutdownSignal
    
    @Throws(NotificationException::class)
    fun `receiveBlocking`(): TapleNotification
    
    @Throws(TapleException::class)
    fun `dropNotifications`()
    
    @Throws(TapleException::class)
    fun `handleNotifications`(`handler`: NotificationHandlerInterface)
    
    fun `getSubjectBuilder`(): SubjectBuilder
    
    @Throws(TapleException::class)
    fun `shutdownGracefully`()
    
}

class TapleNode(
    pointer: Pointer
) : FFIObject(pointer), TapleNodeInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    override protected fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_taple_ffi_b33d_TapleNode_object_free(this.pointer, status)
        }
    }

    override fun `getApi`(): TapleApi =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.taple_ffi_b33d_TapleNode_get_api(it,  _status)
}
        }.let {
            FfiConverterTypeTapleApi.lift(it)
        }
    override fun `getShutdownHandler`(): ShutdownSignal =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.taple_ffi_b33d_TapleNode_get_shutdown_handler(it,  _status)
}
        }.let {
            FfiConverterTypeShutdownSignal.lift(it)
        }
    
    @Throws(NotificationException::class)override fun `receiveBlocking`(): TapleNotification =
        callWithPointer {
    rustCallWithError(NotificationException) { _status ->
    _UniFFILib.INSTANCE.taple_ffi_b33d_TapleNode_receive_blocking(it,  _status)
}
        }.let {
            FfiConverterTypeTapleNotification.lift(it)
        }
    
    @Throws(TapleException::class)override fun `dropNotifications`() =
        callWithPointer {
    rustCallWithError(TapleException) { _status ->
    _UniFFILib.INSTANCE.taple_ffi_b33d_TapleNode_drop_notifications(it,  _status)
}
        }
    
    
    @Throws(TapleException::class)override fun `handleNotifications`(`handler`: NotificationHandlerInterface) =
        callWithPointer {
    rustCallWithError(TapleException) { _status ->
    _UniFFILib.INSTANCE.taple_ffi_b33d_TapleNode_handle_notifications(it, FfiConverterTypeNotificationHandlerInterface.lower(`handler`),  _status)
}
        }
    
    override fun `getSubjectBuilder`(): SubjectBuilder =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.taple_ffi_b33d_TapleNode_get_subject_builder(it,  _status)
}
        }.let {
            FfiConverterTypeSubjectBuilder.lift(it)
        }
    
    @Throws(TapleException::class)override fun `shutdownGracefully`() =
        callWithPointer {
    rustCallWithError(TapleException) { _status ->
    _UniFFILib.INSTANCE.taple_ffi_b33d_TapleNode_shutdown_gracefully(it,  _status)
}
        }
    
    

    
}

public object FfiConverterTypeTapleNode: FfiConverter<TapleNode, Pointer> {
    override fun lower(value: TapleNode): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): TapleNode {
        return TapleNode(value)
    }

    override fun read(buf: ByteBuffer): TapleNode {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: TapleNode) = 8

    override fun write(value: TapleNode, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}




public interface UserGovernanceInterface {
    
    @Throws(TapleException::class)
    fun `getMembers`(): List<String>
    
    @Throws(TapleException::class)
    fun `getSchemas`(): List<Schema>
    
    @Throws(TapleException::class)
    fun `getPolicies`(): List<Policy>
    
    @Throws(TapleException::class)
    fun `getRoles`(): List<Role>
    
    @Throws(TapleException::class)
    fun `refresh`()
    
    fun `getSubjectId`(): String
    
    fun `getGovernanceId`(): String
    
    fun `getSn`(): ULong
    
    fun `getPublicKey`(): String
    
    fun `getNamespace`(): String
    
    fun `getSchemaId`(): String
    
    fun `getOwner`(): String
    
    fun `getCreator`(): String
    
    fun `getProperties`(): String
    
    fun `getIsActive`(): Boolean
    
}

class UserGovernance(
    pointer: Pointer
) : FFIObject(pointer), UserGovernanceInterface {
    constructor(`subject`: UserSubject) :
        this(
    rustCallWithError(TapleException) { _status ->
    _UniFFILib.INSTANCE.taple_ffi_b33d_UserGovernance_new(FfiConverterTypeUserSubject.lower(`subject`), _status)
})

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    override protected fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_taple_ffi_b33d_UserGovernance_object_free(this.pointer, status)
        }
    }

    
    @Throws(TapleException::class)override fun `getMembers`(): List<String> =
        callWithPointer {
    rustCallWithError(TapleException) { _status ->
    _UniFFILib.INSTANCE.taple_ffi_b33d_UserGovernance_get_members(it,  _status)
}
        }.let {
            FfiConverterSequenceString.lift(it)
        }
    
    @Throws(TapleException::class)override fun `getSchemas`(): List<Schema> =
        callWithPointer {
    rustCallWithError(TapleException) { _status ->
    _UniFFILib.INSTANCE.taple_ffi_b33d_UserGovernance_get_schemas(it,  _status)
}
        }.let {
            FfiConverterSequenceTypeSchema.lift(it)
        }
    
    @Throws(TapleException::class)override fun `getPolicies`(): List<Policy> =
        callWithPointer {
    rustCallWithError(TapleException) { _status ->
    _UniFFILib.INSTANCE.taple_ffi_b33d_UserGovernance_get_policies(it,  _status)
}
        }.let {
            FfiConverterSequenceTypePolicy.lift(it)
        }
    
    @Throws(TapleException::class)override fun `getRoles`(): List<Role> =
        callWithPointer {
    rustCallWithError(TapleException) { _status ->
    _UniFFILib.INSTANCE.taple_ffi_b33d_UserGovernance_get_roles(it,  _status)
}
        }.let {
            FfiConverterSequenceTypeRole.lift(it)
        }
    
    @Throws(TapleException::class)override fun `refresh`() =
        callWithPointer {
    rustCallWithError(TapleException) { _status ->
    _UniFFILib.INSTANCE.taple_ffi_b33d_UserGovernance_refresh(it,  _status)
}
        }
    
    override fun `getSubjectId`(): String =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.taple_ffi_b33d_UserGovernance_get_subject_id(it,  _status)
}
        }.let {
            FfiConverterString.lift(it)
        }
    override fun `getGovernanceId`(): String =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.taple_ffi_b33d_UserGovernance_get_governance_id(it,  _status)
}
        }.let {
            FfiConverterString.lift(it)
        }
    override fun `getSn`(): ULong =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.taple_ffi_b33d_UserGovernance_get_sn(it,  _status)
}
        }.let {
            FfiConverterULong.lift(it)
        }
    override fun `getPublicKey`(): String =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.taple_ffi_b33d_UserGovernance_get_public_key(it,  _status)
}
        }.let {
            FfiConverterString.lift(it)
        }
    override fun `getNamespace`(): String =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.taple_ffi_b33d_UserGovernance_get_namespace(it,  _status)
}
        }.let {
            FfiConverterString.lift(it)
        }
    override fun `getSchemaId`(): String =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.taple_ffi_b33d_UserGovernance_get_schema_id(it,  _status)
}
        }.let {
            FfiConverterString.lift(it)
        }
    override fun `getOwner`(): String =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.taple_ffi_b33d_UserGovernance_get_owner(it,  _status)
}
        }.let {
            FfiConverterString.lift(it)
        }
    override fun `getCreator`(): String =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.taple_ffi_b33d_UserGovernance_get_creator(it,  _status)
}
        }.let {
            FfiConverterString.lift(it)
        }
    override fun `getProperties`(): String =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.taple_ffi_b33d_UserGovernance_get_properties(it,  _status)
}
        }.let {
            FfiConverterString.lift(it)
        }
    override fun `getIsActive`(): Boolean =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.taple_ffi_b33d_UserGovernance_get_is_active(it,  _status)
}
        }.let {
            FfiConverterBoolean.lift(it)
        }
    

    
}

public object FfiConverterTypeUserGovernance: FfiConverter<UserGovernance, Pointer> {
    override fun lower(value: UserGovernance): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): UserGovernance {
        return UserGovernance(value)
    }

    override fun read(buf: ByteBuffer): UserGovernance {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: UserGovernance) = 8

    override fun write(value: UserGovernance, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}




public interface UserSubjectInterface {
    
    @Throws(TapleException::class)
    fun `endLifeCicle`(): String
    
    @Throws(TapleException::class)
    fun `newFactEvent`(`payload`: String): String
    
    @Throws(TapleException::class)
    fun `refresh`()
    
    @Throws(TapleException::class)
    fun `externalInvokation`(`event`: TapleSignedEventRequest): String
    
    fun `toGovernance`(): UserGovernance?
    
    fun `getSubjectId`(): String?
    
    fun `getGovernanceId`(): String?
    
    fun `getSn`(): ULong?
    
    fun `getPublicKey`(): String?
    
    fun `getNamespace`(): String?
    
    fun `getSchemaId`(): String?
    
    fun `getOwner`(): String?
    
    fun `getCreator`(): String?
    
    fun `getProperties`(): String?
    
    fun `getSubjectRequest`(): String?
    
    fun `getIsActive`(): Boolean?
    
}

class UserSubject(
    pointer: Pointer
) : FFIObject(pointer), UserSubjectInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    override protected fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_taple_ffi_b33d_UserSubject_object_free(this.pointer, status)
        }
    }

    
    @Throws(TapleException::class)override fun `endLifeCicle`(): String =
        callWithPointer {
    rustCallWithError(TapleException) { _status ->
    _UniFFILib.INSTANCE.taple_ffi_b33d_UserSubject_end_life_cicle(it,  _status)
}
        }.let {
            FfiConverterString.lift(it)
        }
    
    @Throws(TapleException::class)override fun `newFactEvent`(`payload`: String): String =
        callWithPointer {
    rustCallWithError(TapleException) { _status ->
    _UniFFILib.INSTANCE.taple_ffi_b33d_UserSubject_new_fact_event(it, FfiConverterString.lower(`payload`),  _status)
}
        }.let {
            FfiConverterString.lift(it)
        }
    
    @Throws(TapleException::class)override fun `refresh`() =
        callWithPointer {
    rustCallWithError(TapleException) { _status ->
    _UniFFILib.INSTANCE.taple_ffi_b33d_UserSubject_refresh(it,  _status)
}
        }
    
    
    @Throws(TapleException::class)override fun `externalInvokation`(`event`: TapleSignedEventRequest): String =
        callWithPointer {
    rustCallWithError(TapleException) { _status ->
    _UniFFILib.INSTANCE.taple_ffi_b33d_UserSubject_external_invokation(it, FfiConverterTypeTapleSignedEventRequest.lower(`event`),  _status)
}
        }.let {
            FfiConverterString.lift(it)
        }
    override fun `toGovernance`(): UserGovernance? =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.taple_ffi_b33d_UserSubject_to_governance(it,  _status)
}
        }.let {
            FfiConverterOptionalTypeUserGovernance.lift(it)
        }
    override fun `getSubjectId`(): String? =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.taple_ffi_b33d_UserSubject_get_subject_id(it,  _status)
}
        }.let {
            FfiConverterOptionalString.lift(it)
        }
    override fun `getGovernanceId`(): String? =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.taple_ffi_b33d_UserSubject_get_governance_id(it,  _status)
}
        }.let {
            FfiConverterOptionalString.lift(it)
        }
    override fun `getSn`(): ULong? =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.taple_ffi_b33d_UserSubject_get_sn(it,  _status)
}
        }.let {
            FfiConverterOptionalULong.lift(it)
        }
    override fun `getPublicKey`(): String? =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.taple_ffi_b33d_UserSubject_get_public_key(it,  _status)
}
        }.let {
            FfiConverterOptionalString.lift(it)
        }
    override fun `getNamespace`(): String? =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.taple_ffi_b33d_UserSubject_get_namespace(it,  _status)
}
        }.let {
            FfiConverterOptionalString.lift(it)
        }
    override fun `getSchemaId`(): String? =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.taple_ffi_b33d_UserSubject_get_schema_id(it,  _status)
}
        }.let {
            FfiConverterOptionalString.lift(it)
        }
    override fun `getOwner`(): String? =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.taple_ffi_b33d_UserSubject_get_owner(it,  _status)
}
        }.let {
            FfiConverterOptionalString.lift(it)
        }
    override fun `getCreator`(): String? =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.taple_ffi_b33d_UserSubject_get_creator(it,  _status)
}
        }.let {
            FfiConverterOptionalString.lift(it)
        }
    override fun `getProperties`(): String? =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.taple_ffi_b33d_UserSubject_get_properties(it,  _status)
}
        }.let {
            FfiConverterOptionalString.lift(it)
        }
    override fun `getSubjectRequest`(): String? =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.taple_ffi_b33d_UserSubject_get_subject_request(it,  _status)
}
        }.let {
            FfiConverterOptionalString.lift(it)
        }
    override fun `getIsActive`(): Boolean? =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.taple_ffi_b33d_UserSubject_get_is_active(it,  _status)
}
        }.let {
            FfiConverterOptionalBoolean.lift(it)
        }
    

    
}

public object FfiConverterTypeUserSubject: FfiConverter<UserSubject, Pointer> {
    override fun lower(value: UserSubject): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): UserSubject {
        return UserSubject(value)
    }

    override fun read(buf: ByteBuffer): UserSubject {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: UserSubject) = 8

    override fun write(value: UserSubject, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}




data class Policy (
    var `id`: String, 
    var `approve`: Validation, 
    var `evaluate`: Validation, 
    var `validate`: Validation
) {
    
}

public object FfiConverterTypePolicy: FfiConverterRustBuffer<Policy> {
    override fun read(buf: ByteBuffer): Policy {
        return Policy(
            FfiConverterString.read(buf),
            FfiConverterTypeValidation.read(buf),
            FfiConverterTypeValidation.read(buf),
            FfiConverterTypeValidation.read(buf),
        )
    }

    override fun allocationSize(value: Policy) = (
            FfiConverterString.allocationSize(value.`id`) +
            FfiConverterTypeValidation.allocationSize(value.`approve`) +
            FfiConverterTypeValidation.allocationSize(value.`evaluate`) +
            FfiConverterTypeValidation.allocationSize(value.`validate`)
    )

    override fun write(value: Policy, buf: ByteBuffer) {
            FfiConverterString.write(value.`id`, buf)
            FfiConverterTypeValidation.write(value.`approve`, buf)
            FfiConverterTypeValidation.write(value.`evaluate`, buf)
            FfiConverterTypeValidation.write(value.`validate`, buf)
    }
}




data class Role (
    var `who`: Who, 
    var `namespace`: String, 
    var `role`: RoleEnum, 
    var `schema`: SchemaEnum
) {
    
}

public object FfiConverterTypeRole: FfiConverterRustBuffer<Role> {
    override fun read(buf: ByteBuffer): Role {
        return Role(
            FfiConverterTypeWho.read(buf),
            FfiConverterString.read(buf),
            FfiConverterTypeRoleEnum.read(buf),
            FfiConverterTypeSchemaEnum.read(buf),
        )
    }

    override fun allocationSize(value: Role) = (
            FfiConverterTypeWho.allocationSize(value.`who`) +
            FfiConverterString.allocationSize(value.`namespace`) +
            FfiConverterTypeRoleEnum.allocationSize(value.`role`) +
            FfiConverterTypeSchemaEnum.allocationSize(value.`schema`)
    )

    override fun write(value: Role, buf: ByteBuffer) {
            FfiConverterTypeWho.write(value.`who`, buf)
            FfiConverterString.write(value.`namespace`, buf)
            FfiConverterTypeRoleEnum.write(value.`role`, buf)
            FfiConverterTypeSchemaEnum.write(value.`schema`, buf)
    }
}




data class Schema (
    var `id`: String, 
    var `schema`: String, 
    var `initialValue`: String
) {
    
}

public object FfiConverterTypeSchema: FfiConverterRustBuffer<Schema> {
    override fun read(buf: ByteBuffer): Schema {
        return Schema(
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: Schema) = (
            FfiConverterString.allocationSize(value.`id`) +
            FfiConverterString.allocationSize(value.`schema`) +
            FfiConverterString.allocationSize(value.`initialValue`)
    )

    override fun write(value: Schema, buf: ByteBuffer) {
            FfiConverterString.write(value.`id`, buf)
            FfiConverterString.write(value.`schema`, buf)
            FfiConverterString.write(value.`initialValue`, buf)
    }
}




data class SubjectAndProviders (
    var `subjectId`: String, 
    var `providers`: List<String>
) {
    
}

public object FfiConverterTypeSubjectAndProviders: FfiConverterRustBuffer<SubjectAndProviders> {
    override fun read(buf: ByteBuffer): SubjectAndProviders {
        return SubjectAndProviders(
            FfiConverterString.read(buf),
            FfiConverterSequenceString.read(buf),
        )
    }

    override fun allocationSize(value: SubjectAndProviders) = (
            FfiConverterString.allocationSize(value.`subjectId`) +
            FfiConverterSequenceString.allocationSize(value.`providers`)
    )

    override fun write(value: SubjectAndProviders, buf: ByteBuffer) {
            FfiConverterString.write(value.`subjectId`, buf)
            FfiConverterSequenceString.write(value.`providers`, buf)
    }
}




data class TapleApprovalEntity (
    var `id`: String, 
    var `request`: TapleSignedApprovalRequest, 
    var `response`: TapleSignedApprovalResponse?, 
    var `state`: TapleApprovalState
) {
    
}

public object FfiConverterTypeTapleApprovalEntity: FfiConverterRustBuffer<TapleApprovalEntity> {
    override fun read(buf: ByteBuffer): TapleApprovalEntity {
        return TapleApprovalEntity(
            FfiConverterString.read(buf),
            FfiConverterTypeTapleSignedApprovalRequest.read(buf),
            FfiConverterOptionalTypeTapleSignedApprovalResponse.read(buf),
            FfiConverterTypeTapleApprovalState.read(buf),
        )
    }

    override fun allocationSize(value: TapleApprovalEntity) = (
            FfiConverterString.allocationSize(value.`id`) +
            FfiConverterTypeTapleSignedApprovalRequest.allocationSize(value.`request`) +
            FfiConverterOptionalTypeTapleSignedApprovalResponse.allocationSize(value.`response`) +
            FfiConverterTypeTapleApprovalState.allocationSize(value.`state`)
    )

    override fun write(value: TapleApprovalEntity, buf: ByteBuffer) {
            FfiConverterString.write(value.`id`, buf)
            FfiConverterTypeTapleSignedApprovalRequest.write(value.`request`, buf)
            FfiConverterOptionalTypeTapleSignedApprovalResponse.write(value.`response`, buf)
            FfiConverterTypeTapleApprovalState.write(value.`state`, buf)
    }
}




data class TapleApprovalRequest (
    var `eventRequest`: TapleSignedEventRequest, 
    var `sn`: ULong, 
    var `govVersion`: ULong, 
    var `patch`: String, 
    var `stateHash`: String, 
    var `hashPrevEvent`: String, 
    var `govId`: String
) {
    
}

public object FfiConverterTypeTapleApprovalRequest: FfiConverterRustBuffer<TapleApprovalRequest> {
    override fun read(buf: ByteBuffer): TapleApprovalRequest {
        return TapleApprovalRequest(
            FfiConverterTypeTapleSignedEventRequest.read(buf),
            FfiConverterULong.read(buf),
            FfiConverterULong.read(buf),
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: TapleApprovalRequest) = (
            FfiConverterTypeTapleSignedEventRequest.allocationSize(value.`eventRequest`) +
            FfiConverterULong.allocationSize(value.`sn`) +
            FfiConverterULong.allocationSize(value.`govVersion`) +
            FfiConverterString.allocationSize(value.`patch`) +
            FfiConverterString.allocationSize(value.`stateHash`) +
            FfiConverterString.allocationSize(value.`hashPrevEvent`) +
            FfiConverterString.allocationSize(value.`govId`)
    )

    override fun write(value: TapleApprovalRequest, buf: ByteBuffer) {
            FfiConverterTypeTapleSignedEventRequest.write(value.`eventRequest`, buf)
            FfiConverterULong.write(value.`sn`, buf)
            FfiConverterULong.write(value.`govVersion`, buf)
            FfiConverterString.write(value.`patch`, buf)
            FfiConverterString.write(value.`stateHash`, buf)
            FfiConverterString.write(value.`hashPrevEvent`, buf)
            FfiConverterString.write(value.`govId`, buf)
    }
}




data class TapleApprovalResponse (
    var `apprReqHash`: String, 
    var `approved`: Boolean
) {
    
}

public object FfiConverterTypeTapleApprovalResponse: FfiConverterRustBuffer<TapleApprovalResponse> {
    override fun read(buf: ByteBuffer): TapleApprovalResponse {
        return TapleApprovalResponse(
            FfiConverterString.read(buf),
            FfiConverterBoolean.read(buf),
        )
    }

    override fun allocationSize(value: TapleApprovalResponse) = (
            FfiConverterString.allocationSize(value.`apprReqHash`) +
            FfiConverterBoolean.allocationSize(value.`approved`)
    )

    override fun write(value: TapleApprovalResponse, buf: ByteBuffer) {
            FfiConverterString.write(value.`apprReqHash`, buf)
            FfiConverterBoolean.write(value.`approved`, buf)
    }
}




data class TapleEvent (
    var `subjectId`: String, 
    var `eventRequest`: TapleSignedEventRequest, 
    var `sn`: ULong, 
    var `govVersion`: ULong, 
    var `patch`: String, 
    var `stateHash`: String, 
    var `evalSuccess`: Boolean, 
    var `apprRequired`: Boolean, 
    var `approved`: Boolean, 
    var `hashPrevEvent`: String, 
    var `evaluators`: Map<String, TapleSignature>, 
    var `approvers`: Map<String, TapleSignature>
) {
    
}

public object FfiConverterTypeTapleEvent: FfiConverterRustBuffer<TapleEvent> {
    override fun read(buf: ByteBuffer): TapleEvent {
        return TapleEvent(
            FfiConverterString.read(buf),
            FfiConverterTypeTapleSignedEventRequest.read(buf),
            FfiConverterULong.read(buf),
            FfiConverterULong.read(buf),
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterString.read(buf),
            FfiConverterMapStringTapleSignature.read(buf),
            FfiConverterMapStringTapleSignature.read(buf),
        )
    }

    override fun allocationSize(value: TapleEvent) = (
            FfiConverterString.allocationSize(value.`subjectId`) +
            FfiConverterTypeTapleSignedEventRequest.allocationSize(value.`eventRequest`) +
            FfiConverterULong.allocationSize(value.`sn`) +
            FfiConverterULong.allocationSize(value.`govVersion`) +
            FfiConverterString.allocationSize(value.`patch`) +
            FfiConverterString.allocationSize(value.`stateHash`) +
            FfiConverterBoolean.allocationSize(value.`evalSuccess`) +
            FfiConverterBoolean.allocationSize(value.`apprRequired`) +
            FfiConverterBoolean.allocationSize(value.`approved`) +
            FfiConverterString.allocationSize(value.`hashPrevEvent`) +
            FfiConverterMapStringTapleSignature.allocationSize(value.`evaluators`) +
            FfiConverterMapStringTapleSignature.allocationSize(value.`approvers`)
    )

    override fun write(value: TapleEvent, buf: ByteBuffer) {
            FfiConverterString.write(value.`subjectId`, buf)
            FfiConverterTypeTapleSignedEventRequest.write(value.`eventRequest`, buf)
            FfiConverterULong.write(value.`sn`, buf)
            FfiConverterULong.write(value.`govVersion`, buf)
            FfiConverterString.write(value.`patch`, buf)
            FfiConverterString.write(value.`stateHash`, buf)
            FfiConverterBoolean.write(value.`evalSuccess`, buf)
            FfiConverterBoolean.write(value.`apprRequired`, buf)
            FfiConverterBoolean.write(value.`approved`, buf)
            FfiConverterString.write(value.`hashPrevEvent`, buf)
            FfiConverterMapStringTapleSignature.write(value.`evaluators`, buf)
            FfiConverterMapStringTapleSignature.write(value.`approvers`, buf)
    }
}




data class TapleRequest (
    var `id`: String, 
    var `subjectId`: String?, 
    var `sn`: ULong, 
    var `eventRequest`: TapleSignedEventRequest, 
    var `state`: TapleRequestState, 
    var `success`: Boolean
) {
    
}

public object FfiConverterTypeTapleRequest: FfiConverterRustBuffer<TapleRequest> {
    override fun read(buf: ByteBuffer): TapleRequest {
        return TapleRequest(
            FfiConverterString.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterULong.read(buf),
            FfiConverterTypeTapleSignedEventRequest.read(buf),
            FfiConverterTypeTapleRequestState.read(buf),
            FfiConverterBoolean.read(buf),
        )
    }

    override fun allocationSize(value: TapleRequest) = (
            FfiConverterString.allocationSize(value.`id`) +
            FfiConverterOptionalString.allocationSize(value.`subjectId`) +
            FfiConverterULong.allocationSize(value.`sn`) +
            FfiConverterTypeTapleSignedEventRequest.allocationSize(value.`eventRequest`) +
            FfiConverterTypeTapleRequestState.allocationSize(value.`state`) +
            FfiConverterBoolean.allocationSize(value.`success`)
    )

    override fun write(value: TapleRequest, buf: ByteBuffer) {
            FfiConverterString.write(value.`id`, buf)
            FfiConverterOptionalString.write(value.`subjectId`, buf)
            FfiConverterULong.write(value.`sn`, buf)
            FfiConverterTypeTapleSignedEventRequest.write(value.`eventRequest`, buf)
            FfiConverterTypeTapleRequestState.write(value.`state`, buf)
            FfiConverterBoolean.write(value.`success`, buf)
    }
}




data class TapleSettings (
    var `listenAddr`: List<String>, 
    var `keyDerivator`: TapleKeyDerivator, 
    var `privateKey`: List<UByte>, 
    var `knownNodes`: List<String>
) {
    
}

public object FfiConverterTypeTapleSettings: FfiConverterRustBuffer<TapleSettings> {
    override fun read(buf: ByteBuffer): TapleSettings {
        return TapleSettings(
            FfiConverterSequenceString.read(buf),
            FfiConverterTypeTapleKeyDerivator.read(buf),
            FfiConverterSequenceUByte.read(buf),
            FfiConverterSequenceString.read(buf),
        )
    }

    override fun allocationSize(value: TapleSettings) = (
            FfiConverterSequenceString.allocationSize(value.`listenAddr`) +
            FfiConverterTypeTapleKeyDerivator.allocationSize(value.`keyDerivator`) +
            FfiConverterSequenceUByte.allocationSize(value.`privateKey`) +
            FfiConverterSequenceString.allocationSize(value.`knownNodes`)
    )

    override fun write(value: TapleSettings, buf: ByteBuffer) {
            FfiConverterSequenceString.write(value.`listenAddr`, buf)
            FfiConverterTypeTapleKeyDerivator.write(value.`keyDerivator`, buf)
            FfiConverterSequenceUByte.write(value.`privateKey`, buf)
            FfiConverterSequenceString.write(value.`knownNodes`, buf)
    }
}




data class TapleSignature (
    var `signer`: String, 
    var `timestamp`: ULong, 
    var `value`: String
) {
    
}

public object FfiConverterTypeTapleSignature: FfiConverterRustBuffer<TapleSignature> {
    override fun read(buf: ByteBuffer): TapleSignature {
        return TapleSignature(
            FfiConverterString.read(buf),
            FfiConverterULong.read(buf),
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: TapleSignature) = (
            FfiConverterString.allocationSize(value.`signer`) +
            FfiConverterULong.allocationSize(value.`timestamp`) +
            FfiConverterString.allocationSize(value.`value`)
    )

    override fun write(value: TapleSignature, buf: ByteBuffer) {
            FfiConverterString.write(value.`signer`, buf)
            FfiConverterULong.write(value.`timestamp`, buf)
            FfiConverterString.write(value.`value`, buf)
    }
}




data class TapleSignedApprovalRequest (
    var `content`: TapleApprovalRequest, 
    var `signature`: TapleSignature
) {
    
}

public object FfiConverterTypeTapleSignedApprovalRequest: FfiConverterRustBuffer<TapleSignedApprovalRequest> {
    override fun read(buf: ByteBuffer): TapleSignedApprovalRequest {
        return TapleSignedApprovalRequest(
            FfiConverterTypeTapleApprovalRequest.read(buf),
            FfiConverterTypeTapleSignature.read(buf),
        )
    }

    override fun allocationSize(value: TapleSignedApprovalRequest) = (
            FfiConverterTypeTapleApprovalRequest.allocationSize(value.`content`) +
            FfiConverterTypeTapleSignature.allocationSize(value.`signature`)
    )

    override fun write(value: TapleSignedApprovalRequest, buf: ByteBuffer) {
            FfiConverterTypeTapleApprovalRequest.write(value.`content`, buf)
            FfiConverterTypeTapleSignature.write(value.`signature`, buf)
    }
}




data class TapleSignedApprovalResponse (
    var `content`: TapleApprovalResponse, 
    var `signature`: TapleSignature
) {
    
}

public object FfiConverterTypeTapleSignedApprovalResponse: FfiConverterRustBuffer<TapleSignedApprovalResponse> {
    override fun read(buf: ByteBuffer): TapleSignedApprovalResponse {
        return TapleSignedApprovalResponse(
            FfiConverterTypeTapleApprovalResponse.read(buf),
            FfiConverterTypeTapleSignature.read(buf),
        )
    }

    override fun allocationSize(value: TapleSignedApprovalResponse) = (
            FfiConverterTypeTapleApprovalResponse.allocationSize(value.`content`) +
            FfiConverterTypeTapleSignature.allocationSize(value.`signature`)
    )

    override fun write(value: TapleSignedApprovalResponse, buf: ByteBuffer) {
            FfiConverterTypeTapleApprovalResponse.write(value.`content`, buf)
            FfiConverterTypeTapleSignature.write(value.`signature`, buf)
    }
}




data class TapleSignedEvent (
    var `content`: TapleEvent, 
    var `signature`: TapleSignature
) {
    
}

public object FfiConverterTypeTapleSignedEvent: FfiConverterRustBuffer<TapleSignedEvent> {
    override fun read(buf: ByteBuffer): TapleSignedEvent {
        return TapleSignedEvent(
            FfiConverterTypeTapleEvent.read(buf),
            FfiConverterTypeTapleSignature.read(buf),
        )
    }

    override fun allocationSize(value: TapleSignedEvent) = (
            FfiConverterTypeTapleEvent.allocationSize(value.`content`) +
            FfiConverterTypeTapleSignature.allocationSize(value.`signature`)
    )

    override fun write(value: TapleSignedEvent, buf: ByteBuffer) {
            FfiConverterTypeTapleEvent.write(value.`content`, buf)
            FfiConverterTypeTapleSignature.write(value.`signature`, buf)
    }
}




data class TapleSignedEventRequest (
    var `content`: EventRequestType, 
    var `signature`: TapleSignature
) {
    
}

public object FfiConverterTypeTapleSignedEventRequest: FfiConverterRustBuffer<TapleSignedEventRequest> {
    override fun read(buf: ByteBuffer): TapleSignedEventRequest {
        return TapleSignedEventRequest(
            FfiConverterTypeEventRequestType.read(buf),
            FfiConverterTypeTapleSignature.read(buf),
        )
    }

    override fun allocationSize(value: TapleSignedEventRequest) = (
            FfiConverterTypeEventRequestType.allocationSize(value.`content`) +
            FfiConverterTypeTapleSignature.allocationSize(value.`signature`)
    )

    override fun write(value: TapleSignedEventRequest, buf: ByteBuffer) {
            FfiConverterTypeEventRequestType.write(value.`content`, buf)
            FfiConverterTypeTapleSignature.write(value.`signature`, buf)
    }
}




data class Tuple (
    var `key`: String, 
    var `value`: List<UByte>
) {
    
}

public object FfiConverterTypeTuple: FfiConverterRustBuffer<Tuple> {
    override fun read(buf: ByteBuffer): Tuple {
        return Tuple(
            FfiConverterString.read(buf),
            FfiConverterSequenceUByte.read(buf),
        )
    }

    override fun allocationSize(value: Tuple) = (
            FfiConverterString.allocationSize(value.`key`) +
            FfiConverterSequenceUByte.allocationSize(value.`value`)
    )

    override fun write(value: Tuple, buf: ByteBuffer) {
            FfiConverterString.write(value.`key`, buf)
            FfiConverterSequenceUByte.write(value.`value`, buf)
    }
}




data class Validation (
    var `quorum`: Quorum
) {
    
}

public object FfiConverterTypeValidation: FfiConverterRustBuffer<Validation> {
    override fun read(buf: ByteBuffer): Validation {
        return Validation(
            FfiConverterTypeQuorum.read(buf),
        )
    }

    override fun allocationSize(value: Validation) = (
            FfiConverterTypeQuorum.allocationSize(value.`quorum`)
    )

    override fun write(value: Validation, buf: ByteBuffer) {
            FfiConverterTypeQuorum.write(value.`quorum`, buf)
    }
}




data class ValidationProof (
    var `subjectId`: String, 
    var `schemaId`: String, 
    var `namespace`: String, 
    var `name`: String, 
    var `subjectPublicKey`: String, 
    var `governanceId`: String, 
    var `genesisGovernanceVersion`: ULong, 
    var `sn`: ULong, 
    var `prevEventHash`: String, 
    var `eventHash`: String, 
    var `governanceVersion`: ULong
) {
    
}

public object FfiConverterTypeValidationProof: FfiConverterRustBuffer<ValidationProof> {
    override fun read(buf: ByteBuffer): ValidationProof {
        return ValidationProof(
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterULong.read(buf),
            FfiConverterULong.read(buf),
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterULong.read(buf),
        )
    }

    override fun allocationSize(value: ValidationProof) = (
            FfiConverterString.allocationSize(value.`subjectId`) +
            FfiConverterString.allocationSize(value.`schemaId`) +
            FfiConverterString.allocationSize(value.`namespace`) +
            FfiConverterString.allocationSize(value.`name`) +
            FfiConverterString.allocationSize(value.`subjectPublicKey`) +
            FfiConverterString.allocationSize(value.`governanceId`) +
            FfiConverterULong.allocationSize(value.`genesisGovernanceVersion`) +
            FfiConverterULong.allocationSize(value.`sn`) +
            FfiConverterString.allocationSize(value.`prevEventHash`) +
            FfiConverterString.allocationSize(value.`eventHash`) +
            FfiConverterULong.allocationSize(value.`governanceVersion`)
    )

    override fun write(value: ValidationProof, buf: ByteBuffer) {
            FfiConverterString.write(value.`subjectId`, buf)
            FfiConverterString.write(value.`schemaId`, buf)
            FfiConverterString.write(value.`namespace`, buf)
            FfiConverterString.write(value.`name`, buf)
            FfiConverterString.write(value.`subjectPublicKey`, buf)
            FfiConverterString.write(value.`governanceId`, buf)
            FfiConverterULong.write(value.`genesisGovernanceVersion`, buf)
            FfiConverterULong.write(value.`sn`, buf)
            FfiConverterString.write(value.`prevEventHash`, buf)
            FfiConverterString.write(value.`eventHash`, buf)
            FfiConverterULong.write(value.`governanceVersion`, buf)
    }
}




data class ValidationProofAndSignatures (
    var `validationProof`: ValidationProof, 
    var `signatures`: List<TapleSignature>
) {
    
}

public object FfiConverterTypeValidationProofAndSignatures: FfiConverterRustBuffer<ValidationProofAndSignatures> {
    override fun read(buf: ByteBuffer): ValidationProofAndSignatures {
        return ValidationProofAndSignatures(
            FfiConverterTypeValidationProof.read(buf),
            FfiConverterSequenceTypeTapleSignature.read(buf),
        )
    }

    override fun allocationSize(value: ValidationProofAndSignatures) = (
            FfiConverterTypeValidationProof.allocationSize(value.`validationProof`) +
            FfiConverterSequenceTypeTapleSignature.allocationSize(value.`signatures`)
    )

    override fun write(value: ValidationProofAndSignatures, buf: ByteBuffer) {
            FfiConverterTypeValidationProof.write(value.`validationProof`, buf)
            FfiConverterSequenceTypeTapleSignature.write(value.`signatures`, buf)
    }
}




sealed class EventRequestType {
    data class Create(
        val `governanceId`: String, 
        val `schemaId`: String, 
        val `namespace`: String, 
        val `name`: String, 
        val `publicKey`: String
        ) : EventRequestType()
    data class Fact(
        val `subjectId`: String, 
        val `payload`: String
        ) : EventRequestType()
    data class Transfer(
        val `subjectId`: String, 
        val `publicKey`: String
        ) : EventRequestType()
    data class Eol(
        val `subjectId`: String
        ) : EventRequestType()
    

    
}

public object FfiConverterTypeEventRequestType : FfiConverterRustBuffer<EventRequestType>{
    override fun read(buf: ByteBuffer): EventRequestType {
        return when(buf.getInt()) {
            1 -> EventRequestType.Create(
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
                )
            2 -> EventRequestType.Fact(
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
                )
            3 -> EventRequestType.Transfer(
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
                )
            4 -> EventRequestType.Eol(
                FfiConverterString.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: EventRequestType) = when(value) {
        is EventRequestType.Create -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterString.allocationSize(value.`governanceId`)
                + FfiConverterString.allocationSize(value.`schemaId`)
                + FfiConverterString.allocationSize(value.`namespace`)
                + FfiConverterString.allocationSize(value.`name`)
                + FfiConverterString.allocationSize(value.`publicKey`)
            )
        }
        is EventRequestType.Fact -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterString.allocationSize(value.`subjectId`)
                + FfiConverterString.allocationSize(value.`payload`)
            )
        }
        is EventRequestType.Transfer -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterString.allocationSize(value.`subjectId`)
                + FfiConverterString.allocationSize(value.`publicKey`)
            )
        }
        is EventRequestType.Eol -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterString.allocationSize(value.`subjectId`)
            )
        }
    }

    override fun write(value: EventRequestType, buf: ByteBuffer) {
        when(value) {
            is EventRequestType.Create -> {
                buf.putInt(1)
                FfiConverterString.write(value.`governanceId`, buf)
                FfiConverterString.write(value.`schemaId`, buf)
                FfiConverterString.write(value.`namespace`, buf)
                FfiConverterString.write(value.`name`, buf)
                FfiConverterString.write(value.`publicKey`, buf)
                Unit
            }
            is EventRequestType.Fact -> {
                buf.putInt(2)
                FfiConverterString.write(value.`subjectId`, buf)
                FfiConverterString.write(value.`payload`, buf)
                Unit
            }
            is EventRequestType.Transfer -> {
                buf.putInt(3)
                FfiConverterString.write(value.`subjectId`, buf)
                FfiConverterString.write(value.`publicKey`, buf)
                Unit
            }
            is EventRequestType.Eol -> {
                buf.putInt(4)
                FfiConverterString.write(value.`subjectId`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}






sealed class Quorum {
    object Majority : Quorum()
    
    data class Fixed(
        val `value`: ULong
        ) : Quorum()
    data class Percentage(
        val `value`: Double
        ) : Quorum()
    

    
}

public object FfiConverterTypeQuorum : FfiConverterRustBuffer<Quorum>{
    override fun read(buf: ByteBuffer): Quorum {
        return when(buf.getInt()) {
            1 -> Quorum.Majority
            2 -> Quorum.Fixed(
                FfiConverterULong.read(buf),
                )
            3 -> Quorum.Percentage(
                FfiConverterDouble.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: Quorum) = when(value) {
        is Quorum.Majority -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
            )
        }
        is Quorum.Fixed -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterULong.allocationSize(value.`value`)
            )
        }
        is Quorum.Percentage -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterDouble.allocationSize(value.`value`)
            )
        }
    }

    override fun write(value: Quorum, buf: ByteBuffer) {
        when(value) {
            is Quorum.Majority -> {
                buf.putInt(1)
                Unit
            }
            is Quorum.Fixed -> {
                buf.putInt(2)
                FfiConverterULong.write(value.`value`, buf)
                Unit
            }
            is Quorum.Percentage -> {
                buf.putInt(3)
                FfiConverterDouble.write(value.`value`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}






enum class RoleEnum {
    VALIDATOR,CREATOR,ISSUER,WITNESS,APPROVER,EVALUATOR;
}

public object FfiConverterTypeRoleEnum: FfiConverterRustBuffer<RoleEnum> {
    override fun read(buf: ByteBuffer) = try {
        RoleEnum.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: RoleEnum) = 4

    override fun write(value: RoleEnum, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}






sealed class SchemaEnum {
    data class Id(
        val `id`: String
        ) : SchemaEnum()
    object NotGovernance : SchemaEnum()
    
    object All : SchemaEnum()
    
    

    
}

public object FfiConverterTypeSchemaEnum : FfiConverterRustBuffer<SchemaEnum>{
    override fun read(buf: ByteBuffer): SchemaEnum {
        return when(buf.getInt()) {
            1 -> SchemaEnum.Id(
                FfiConverterString.read(buf),
                )
            2 -> SchemaEnum.NotGovernance
            3 -> SchemaEnum.All
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: SchemaEnum) = when(value) {
        is SchemaEnum.Id -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterString.allocationSize(value.`id`)
            )
        }
        is SchemaEnum.NotGovernance -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
            )
        }
        is SchemaEnum.All -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
            )
        }
    }

    override fun write(value: SchemaEnum, buf: ByteBuffer) {
        when(value) {
            is SchemaEnum.Id -> {
                buf.putInt(1)
                FfiConverterString.write(value.`id`, buf)
                Unit
            }
            is SchemaEnum.NotGovernance -> {
                buf.putInt(2)
                Unit
            }
            is SchemaEnum.All -> {
                buf.putInt(3)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}






enum class TapleApprovalState {
    PENDING,RESPONDED_ACCEPTED,RESPONDED_REJECTED,OBSOLETE;
}

public object FfiConverterTypeTapleApprovalState: FfiConverterRustBuffer<TapleApprovalState> {
    override fun read(buf: ByteBuffer) = try {
        TapleApprovalState.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: TapleApprovalState) = 4

    override fun write(value: TapleApprovalState, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}






enum class TapleKeyDerivator {
    ED25519,SECP256K1;
}

public object FfiConverterTypeTapleKeyDerivator: FfiConverterRustBuffer<TapleKeyDerivator> {
    override fun read(buf: ByteBuffer) = try {
        TapleKeyDerivator.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: TapleKeyDerivator) = 4

    override fun write(value: TapleKeyDerivator, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}






sealed class TapleNotification {
    data class NewSubject(
        val `subjectId`: String
        ) : TapleNotification()
    data class NewEvent(
        val `sn`: ULong, 
        val `subjectId`: String
        ) : TapleNotification()
    data class StateUpdated(
        val `sn`: ULong, 
        val `subjectId`: String
        ) : TapleNotification()
    data class ApprovalReceived(
        val `id`: String, 
        val `subjectId`: String, 
        val `sn`: ULong
        ) : TapleNotification()
    data class ObsoletedApproval(
        val `id`: String, 
        val `subjectId`: String, 
        val `sn`: ULong
        ) : TapleNotification()
    data class UnrecoverableError(
        val `error`: String
        ) : TapleNotification()
    

    
}

public object FfiConverterTypeTapleNotification : FfiConverterRustBuffer<TapleNotification>{
    override fun read(buf: ByteBuffer): TapleNotification {
        return when(buf.getInt()) {
            1 -> TapleNotification.NewSubject(
                FfiConverterString.read(buf),
                )
            2 -> TapleNotification.NewEvent(
                FfiConverterULong.read(buf),
                FfiConverterString.read(buf),
                )
            3 -> TapleNotification.StateUpdated(
                FfiConverterULong.read(buf),
                FfiConverterString.read(buf),
                )
            4 -> TapleNotification.ApprovalReceived(
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
                FfiConverterULong.read(buf),
                )
            5 -> TapleNotification.ObsoletedApproval(
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
                FfiConverterULong.read(buf),
                )
            6 -> TapleNotification.UnrecoverableError(
                FfiConverterString.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: TapleNotification) = when(value) {
        is TapleNotification.NewSubject -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterString.allocationSize(value.`subjectId`)
            )
        }
        is TapleNotification.NewEvent -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterULong.allocationSize(value.`sn`)
                + FfiConverterString.allocationSize(value.`subjectId`)
            )
        }
        is TapleNotification.StateUpdated -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterULong.allocationSize(value.`sn`)
                + FfiConverterString.allocationSize(value.`subjectId`)
            )
        }
        is TapleNotification.ApprovalReceived -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterString.allocationSize(value.`id`)
                + FfiConverterString.allocationSize(value.`subjectId`)
                + FfiConverterULong.allocationSize(value.`sn`)
            )
        }
        is TapleNotification.ObsoletedApproval -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterString.allocationSize(value.`id`)
                + FfiConverterString.allocationSize(value.`subjectId`)
                + FfiConverterULong.allocationSize(value.`sn`)
            )
        }
        is TapleNotification.UnrecoverableError -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterString.allocationSize(value.`error`)
            )
        }
    }

    override fun write(value: TapleNotification, buf: ByteBuffer) {
        when(value) {
            is TapleNotification.NewSubject -> {
                buf.putInt(1)
                FfiConverterString.write(value.`subjectId`, buf)
                Unit
            }
            is TapleNotification.NewEvent -> {
                buf.putInt(2)
                FfiConverterULong.write(value.`sn`, buf)
                FfiConverterString.write(value.`subjectId`, buf)
                Unit
            }
            is TapleNotification.StateUpdated -> {
                buf.putInt(3)
                FfiConverterULong.write(value.`sn`, buf)
                FfiConverterString.write(value.`subjectId`, buf)
                Unit
            }
            is TapleNotification.ApprovalReceived -> {
                buf.putInt(4)
                FfiConverterString.write(value.`id`, buf)
                FfiConverterString.write(value.`subjectId`, buf)
                FfiConverterULong.write(value.`sn`, buf)
                Unit
            }
            is TapleNotification.ObsoletedApproval -> {
                buf.putInt(5)
                FfiConverterString.write(value.`id`, buf)
                FfiConverterString.write(value.`subjectId`, buf)
                FfiConverterULong.write(value.`sn`, buf)
                Unit
            }
            is TapleNotification.UnrecoverableError -> {
                buf.putInt(6)
                FfiConverterString.write(value.`error`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}






enum class TapleRequestState {
    FINISHED,ERROR,PROCESSING;
}

public object FfiConverterTypeTapleRequestState: FfiConverterRustBuffer<TapleRequestState> {
    override fun read(buf: ByteBuffer) = try {
        TapleRequestState.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: TapleRequestState) = 4

    override fun write(value: TapleRequestState, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}






sealed class Who {
    data class Id(
        val `id`: String
        ) : Who()
    data class Name(
        val `name`: String
        ) : Who()
    object Members : Who()
    
    object All : Who()
    
    object NotMembers : Who()
    
    

    
}

public object FfiConverterTypeWho : FfiConverterRustBuffer<Who>{
    override fun read(buf: ByteBuffer): Who {
        return when(buf.getInt()) {
            1 -> Who.Id(
                FfiConverterString.read(buf),
                )
            2 -> Who.Name(
                FfiConverterString.read(buf),
                )
            3 -> Who.Members
            4 -> Who.All
            5 -> Who.NotMembers
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: Who) = when(value) {
        is Who.Id -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterString.allocationSize(value.`id`)
            )
        }
        is Who.Name -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterString.allocationSize(value.`name`)
            )
        }
        is Who.Members -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
            )
        }
        is Who.All -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
            )
        }
        is Who.NotMembers -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
            )
        }
    }

    override fun write(value: Who, buf: ByteBuffer) {
        when(value) {
            is Who.Id -> {
                buf.putInt(1)
                FfiConverterString.write(value.`id`, buf)
                Unit
            }
            is Who.Name -> {
                buf.putInt(2)
                FfiConverterString.write(value.`name`, buf)
                Unit
            }
            is Who.Members -> {
                buf.putInt(3)
                Unit
            }
            is Who.All -> {
                buf.putInt(4)
                Unit
            }
            is Who.NotMembers -> {
                buf.putInt(5)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}







sealed class DbException(message: String): Exception(message) {
        // Each variant is a nested class
        // Flat enums carries a string error message, so no special implementation is necessary.
        class KeyElementsException(message: String) : DbException(message)
        class InternalDbException(message: String) : DbException(message)
        

    companion object ErrorHandler : CallStatusErrorHandler<DbException> {
        override fun lift(error_buf: RustBuffer.ByValue): DbException = FfiConverterTypeDbError.lift(error_buf)
    }
}

public object FfiConverterTypeDbError : FfiConverterRustBuffer<DbException> {
    override fun read(buf: ByteBuffer): DbException {
        
            return when(buf.getInt()) {
            1 -> DbException.KeyElementsException(FfiConverterString.read(buf))
            2 -> DbException.InternalDbException(FfiConverterString.read(buf))
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }
        
    }

    override fun allocationSize(value: DbException): Int {
        return 4
    }

    override fun write(value: DbException, buf: ByteBuffer) {
        when(value) {
            is DbException.KeyElementsException -> {
                buf.putInt(1)
                Unit
            }
            is DbException.InternalDbException -> {
                buf.putInt(2)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }

}





sealed class InitializationException(message: String): Exception(message) {
        // Each variant is a nested class
        // Flat enums carries a string error message, so no special implementation is necessary.
        class InvalidSettings(message: String) : InitializationException(message)
        class StartFailed(message: String) : InitializationException(message)
        class InternalException(message: String) : InitializationException(message)
        

    companion object ErrorHandler : CallStatusErrorHandler<InitializationException> {
        override fun lift(error_buf: RustBuffer.ByValue): InitializationException = FfiConverterTypeInitializationError.lift(error_buf)
    }
}

public object FfiConverterTypeInitializationError : FfiConverterRustBuffer<InitializationException> {
    override fun read(buf: ByteBuffer): InitializationException {
        
            return when(buf.getInt()) {
            1 -> InitializationException.InvalidSettings(FfiConverterString.read(buf))
            2 -> InitializationException.StartFailed(FfiConverterString.read(buf))
            3 -> InitializationException.InternalException(FfiConverterString.read(buf))
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }
        
    }

    override fun allocationSize(value: InitializationException): Int {
        return 4
    }

    override fun write(value: InitializationException, buf: ByteBuffer) {
        when(value) {
            is InitializationException.InvalidSettings -> {
                buf.putInt(1)
                Unit
            }
            is InitializationException.StartFailed -> {
                buf.putInt(2)
                Unit
            }
            is InitializationException.InternalException -> {
                buf.putInt(3)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }

}





sealed class NotificationException(message: String): Exception(message) {
        // Each variant is a nested class
        // Flat enums carries a string error message, so no special implementation is necessary.
        class NoConnection(message: String) : NotificationException(message)
        class InternalException(message: String) : NotificationException(message)
        class LockIsPoisoned(message: String) : NotificationException(message)
        

    companion object ErrorHandler : CallStatusErrorHandler<NotificationException> {
        override fun lift(error_buf: RustBuffer.ByValue): NotificationException = FfiConverterTypeNotificationError.lift(error_buf)
    }
}

public object FfiConverterTypeNotificationError : FfiConverterRustBuffer<NotificationException> {
    override fun read(buf: ByteBuffer): NotificationException {
        
            return when(buf.getInt()) {
            1 -> NotificationException.NoConnection(FfiConverterString.read(buf))
            2 -> NotificationException.InternalException(FfiConverterString.read(buf))
            3 -> NotificationException.LockIsPoisoned(FfiConverterString.read(buf))
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }
        
    }

    override fun allocationSize(value: NotificationException): Int {
        return 4
    }

    override fun write(value: NotificationException, buf: ByteBuffer) {
        when(value) {
            is NotificationException.NoConnection -> {
                buf.putInt(1)
                Unit
            }
            is NotificationException.InternalException -> {
                buf.putInt(2)
                Unit
            }
            is NotificationException.LockIsPoisoned -> {
                buf.putInt(3)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }

}





sealed class SettingsException(message: String): Exception(message) {
        // Each variant is a nested class
        // Flat enums carries a string error message, so no special implementation is necessary.
        class InvalidListenAddr(message: String) : SettingsException(message)
        class InternalException(message: String) : SettingsException(message)
        

    companion object ErrorHandler : CallStatusErrorHandler<SettingsException> {
        override fun lift(error_buf: RustBuffer.ByValue): SettingsException = FfiConverterTypeSettingsError.lift(error_buf)
    }
}

public object FfiConverterTypeSettingsError : FfiConverterRustBuffer<SettingsException> {
    override fun read(buf: ByteBuffer): SettingsException {
        
            return when(buf.getInt()) {
            1 -> SettingsException.InvalidListenAddr(FfiConverterString.read(buf))
            2 -> SettingsException.InternalException(FfiConverterString.read(buf))
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }
        
    }

    override fun allocationSize(value: SettingsException): Int {
        return 4
    }

    override fun write(value: SettingsException, buf: ByteBuffer) {
        when(value) {
            is SettingsException.InvalidListenAddr -> {
                buf.putInt(1)
                Unit
            }
            is SettingsException.InternalException -> {
                buf.putInt(2)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }

}





sealed class ShutdownException(message: String): Exception(message) {
        // Each variant is a nested class
        // Flat enums carries a string error message, so no special implementation is necessary.
        class InnerLockIsPoisoned(message: String) : ShutdownException(message)
        class InternalException(message: String) : ShutdownException(message)
        

    companion object ErrorHandler : CallStatusErrorHandler<ShutdownException> {
        override fun lift(error_buf: RustBuffer.ByValue): ShutdownException = FfiConverterTypeShutdownError.lift(error_buf)
    }
}

public object FfiConverterTypeShutdownError : FfiConverterRustBuffer<ShutdownException> {
    override fun read(buf: ByteBuffer): ShutdownException {
        
            return when(buf.getInt()) {
            1 -> ShutdownException.InnerLockIsPoisoned(FfiConverterString.read(buf))
            2 -> ShutdownException.InternalException(FfiConverterString.read(buf))
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }
        
    }

    override fun allocationSize(value: ShutdownException): Int {
        return 4
    }

    override fun write(value: ShutdownException, buf: ByteBuffer) {
        when(value) {
            is ShutdownException.InnerLockIsPoisoned -> {
                buf.putInt(1)
                Unit
            }
            is ShutdownException.InternalException -> {
                buf.putInt(2)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }

}





sealed class TapleException(message: String): Exception(message) {
        // Each variant is a nested class
        // Flat enums carries a string error message, so no special implementation is necessary.
        class ExecutionException(message: String) : TapleException(message)
        class NodeUnavailable(message: String) : TapleException(message)
        class NotFound(message: String) : TapleException(message)
        class InternalException(message: String) : TapleException(message)
        class DigestIdentifierGenerationFailed(message: String) : TapleException(message)
        class KeyIdentifierGenerationFailed(message: String) : TapleException(message)
        class SignatureIdentifierGenerationFailed(message: String) : TapleException(message)
        class InvalidKeyDerivator(message: String) : TapleException(message)
        class NoJsonString(message: String) : TapleException(message)
        class SignatureGenerationFailed(message: String) : TapleException(message)
        class LockIsPoisoned(message: String) : TapleException(message)
        class DeserializationException(message: String) : TapleException(message)
        class IncorrectGovernanceProperties(message: String) : TapleException(message)
        

    companion object ErrorHandler : CallStatusErrorHandler<TapleException> {
        override fun lift(error_buf: RustBuffer.ByValue): TapleException = FfiConverterTypeTapleError.lift(error_buf)
    }
}

public object FfiConverterTypeTapleError : FfiConverterRustBuffer<TapleException> {
    override fun read(buf: ByteBuffer): TapleException {
        
            return when(buf.getInt()) {
            1 -> TapleException.ExecutionException(FfiConverterString.read(buf))
            2 -> TapleException.NodeUnavailable(FfiConverterString.read(buf))
            3 -> TapleException.NotFound(FfiConverterString.read(buf))
            4 -> TapleException.InternalException(FfiConverterString.read(buf))
            5 -> TapleException.DigestIdentifierGenerationFailed(FfiConverterString.read(buf))
            6 -> TapleException.KeyIdentifierGenerationFailed(FfiConverterString.read(buf))
            7 -> TapleException.SignatureIdentifierGenerationFailed(FfiConverterString.read(buf))
            8 -> TapleException.InvalidKeyDerivator(FfiConverterString.read(buf))
            9 -> TapleException.NoJsonString(FfiConverterString.read(buf))
            10 -> TapleException.SignatureGenerationFailed(FfiConverterString.read(buf))
            11 -> TapleException.LockIsPoisoned(FfiConverterString.read(buf))
            12 -> TapleException.DeserializationException(FfiConverterString.read(buf))
            13 -> TapleException.IncorrectGovernanceProperties(FfiConverterString.read(buf))
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }
        
    }

    override fun allocationSize(value: TapleException): Int {
        return 4
    }

    override fun write(value: TapleException, buf: ByteBuffer) {
        when(value) {
            is TapleException.ExecutionException -> {
                buf.putInt(1)
                Unit
            }
            is TapleException.NodeUnavailable -> {
                buf.putInt(2)
                Unit
            }
            is TapleException.NotFound -> {
                buf.putInt(3)
                Unit
            }
            is TapleException.InternalException -> {
                buf.putInt(4)
                Unit
            }
            is TapleException.DigestIdentifierGenerationFailed -> {
                buf.putInt(5)
                Unit
            }
            is TapleException.KeyIdentifierGenerationFailed -> {
                buf.putInt(6)
                Unit
            }
            is TapleException.SignatureIdentifierGenerationFailed -> {
                buf.putInt(7)
                Unit
            }
            is TapleException.InvalidKeyDerivator -> {
                buf.putInt(8)
                Unit
            }
            is TapleException.NoJsonString -> {
                buf.putInt(9)
                Unit
            }
            is TapleException.SignatureGenerationFailed -> {
                buf.putInt(10)
                Unit
            }
            is TapleException.LockIsPoisoned -> {
                buf.putInt(11)
                Unit
            }
            is TapleException.DeserializationException -> {
                buf.putInt(12)
                Unit
            }
            is TapleException.IncorrectGovernanceProperties -> {
                buf.putInt(13)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }

}




internal typealias Handle = Long
internal class ConcurrentHandleMap<T>(
    private val leftMap: MutableMap<Handle, T> = mutableMapOf(),
    private val rightMap: MutableMap<T, Handle> = mutableMapOf()
) {
    private val lock = java.util.concurrent.locks.ReentrantLock()
    private val currentHandle = AtomicLong(0L)
    private val stride = 1L

    fun insert(obj: T): Handle =
        lock.withLock {
            rightMap[obj] ?:
                currentHandle.getAndAdd(stride)
                    .also { handle ->
                        leftMap[handle] = obj
                        rightMap[obj] = handle
                    }
            }

    fun get(handle: Handle) = lock.withLock {
        leftMap[handle]
    }

    fun delete(handle: Handle) {
        this.remove(handle)
    }

    fun remove(handle: Handle): T? =
        lock.withLock {
            leftMap.remove(handle)?.let { obj ->
                rightMap.remove(obj)
                obj
            }
        }
}

interface ForeignCallback : com.sun.jna.Callback {
    public fun invoke(handle: Handle, method: Int, args: RustBuffer.ByValue, outBuf: RustBufferByReference): Int
}

// Magic number for the Rust proxy to call using the same mechanism as every other method,
// to free the callback once it's dropped by Rust.
internal const val IDX_CALLBACK_FREE = 0

public abstract class FfiConverterCallbackInterface<CallbackInterface>(
    protected val foreignCallback: ForeignCallback
): FfiConverter<CallbackInterface, Handle> {
    private val handleMap = ConcurrentHandleMap<CallbackInterface>()

    // Registers the foreign callback with the Rust side.
    // This method is generated for each callback interface.
    internal abstract fun register(lib: _UniFFILib)

    fun drop(handle: Handle): RustBuffer.ByValue {
        return handleMap.remove(handle).let { RustBuffer.ByValue() }
    }

    override fun lift(value: Handle): CallbackInterface {
        return handleMap.get(value) ?: throw InternalException("No callback in handlemap; this is a Uniffi bug")
    }

    override fun read(buf: ByteBuffer) = lift(buf.getLong())

    override fun lower(value: CallbackInterface) =
        handleMap.insert(value).also {
            assert(handleMap.get(it) === value) { "Handle map is not returning the object we just placed there. This is a bug in the HandleMap." }
        }

    override fun allocationSize(value: CallbackInterface) = 8

    override fun write(value: CallbackInterface, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}

// Declaration and FfiConverters for DatabaseManagerInterface Callback Interface

public interface DatabaseManagerInterface {
    fun `createCollection`(`identifier`: String): DbCollectionInterface
    
}

// The ForeignCallback that is passed to Rust.
internal class ForeignCallbackTypeDatabaseManagerInterface : ForeignCallback {
    @Suppress("TooGenericExceptionCaught")
    override fun invoke(handle: Handle, method: Int, args: RustBuffer.ByValue, outBuf: RustBufferByReference): Int {
        val cb = FfiConverterTypeDatabaseManagerInterface.lift(handle)
        return when (method) {
            IDX_CALLBACK_FREE -> {
                FfiConverterTypeDatabaseManagerInterface.drop(handle)
                // No return value.
                // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
                0
            }
            1 -> {
                // Call the method, write to outBuf and return a status code
                // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs` for info
                try {
                    val buffer = this.`invokeCreateCollection`(cb, args)
                    // Success
                    outBuf.setValue(buffer)
                    1
                } catch (e: Throwable) {
                    // Unexpected error
                    try {
                        // Try to serialize the error into a string
                        outBuf.setValue(FfiConverterString.lower(e.toString()))
                    } catch (e: Throwable) {
                        // If that fails, then it's time to give up and just return
                    }
                    -1
                }
            }
            
            else -> {
                // An unexpected error happened.
                // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
                try {
                    // Try to serialize the error into a string
                    outBuf.setValue(FfiConverterString.lower("Invalid Callback index"))
                } catch (e: Throwable) {
                    // If that fails, then it's time to give up and just return
                }
                -1
            }
        }
    }

    
    private fun `invokeCreateCollection`(kotlinCallbackInterface: DatabaseManagerInterface, args: RustBuffer.ByValue): RustBuffer.ByValue =
        try {
            val buf = args.asByteBuffer() ?: throw InternalException("No ByteBuffer in RustBuffer; this is a Uniffi bug")
            kotlinCallbackInterface.`createCollection`(
                    FfiConverterString.read(buf)
                    )
            .let {
                    FfiConverterTypeDbCollectionInterface.lowerIntoRustBuffer(it)
                }// TODO catch errors and report them back to Rust.
                // https://github.com/mozilla/uniffi-rs/issues/351
        } finally {
            RustBuffer.free(args)
        }

    
}

// The ffiConverter which transforms the Callbacks in to Handles to pass to Rust.
public object FfiConverterTypeDatabaseManagerInterface: FfiConverterCallbackInterface<DatabaseManagerInterface>(
    foreignCallback = ForeignCallbackTypeDatabaseManagerInterface()
) {
    override fun register(lib: _UniFFILib) {
        rustCall() { status ->
            lib.ffi_taple_ffi_b33d_DatabaseManagerInterface_init_callback(this.foreignCallback, status)
        }
    }
}






// Declaration and FfiConverters for DbCollectionInterface Callback Interface

public interface DbCollectionInterface {
    fun `get`(`key`: String): List<UByte>?
    fun `put`(`key`: String, `value`: List<UByte>)
    fun `del`(`key`: String)
    fun `iter`(`reverse`: Boolean, `prefix`: String): DbCollectionIteratorInterface
    
}

// The ForeignCallback that is passed to Rust.
internal class ForeignCallbackTypeDbCollectionInterface : ForeignCallback {
    @Suppress("TooGenericExceptionCaught")
    override fun invoke(handle: Handle, method: Int, args: RustBuffer.ByValue, outBuf: RustBufferByReference): Int {
        val cb = FfiConverterTypeDbCollectionInterface.lift(handle)
        return when (method) {
            IDX_CALLBACK_FREE -> {
                FfiConverterTypeDbCollectionInterface.drop(handle)
                // No return value.
                // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
                0
            }
            1 -> {
                // Call the method, write to outBuf and return a status code
                // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs` for info
                try {
                    try {
                        val buffer = this.`invokeGet`(cb, args)
                        // Success
                        outBuf.setValue(buffer)
                        1
                    } catch (e: DbException) {
                        // Expected error
                        val buffer = FfiConverterTypeDbError.lowerIntoRustBuffer(e)
                        outBuf.setValue(buffer)
                        -2
                    }
                } catch (e: Throwable) {
                    // Unexpected error
                    try {
                        // Try to serialize the error into a string
                        outBuf.setValue(FfiConverterString.lower(e.toString()))
                    } catch (e: Throwable) {
                        // If that fails, then it's time to give up and just return
                    }
                    -1
                }
            }
            2 -> {
                // Call the method, write to outBuf and return a status code
                // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs` for info
                try {
                    try {
                        val buffer = this.`invokePut`(cb, args)
                        // Success
                        outBuf.setValue(buffer)
                        1
                    } catch (e: DbException) {
                        // Expected error
                        val buffer = FfiConverterTypeDbError.lowerIntoRustBuffer(e)
                        outBuf.setValue(buffer)
                        -2
                    }
                } catch (e: Throwable) {
                    // Unexpected error
                    try {
                        // Try to serialize the error into a string
                        outBuf.setValue(FfiConverterString.lower(e.toString()))
                    } catch (e: Throwable) {
                        // If that fails, then it's time to give up and just return
                    }
                    -1
                }
            }
            3 -> {
                // Call the method, write to outBuf and return a status code
                // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs` for info
                try {
                    try {
                        val buffer = this.`invokeDel`(cb, args)
                        // Success
                        outBuf.setValue(buffer)
                        1
                    } catch (e: DbException) {
                        // Expected error
                        val buffer = FfiConverterTypeDbError.lowerIntoRustBuffer(e)
                        outBuf.setValue(buffer)
                        -2
                    }
                } catch (e: Throwable) {
                    // Unexpected error
                    try {
                        // Try to serialize the error into a string
                        outBuf.setValue(FfiConverterString.lower(e.toString()))
                    } catch (e: Throwable) {
                        // If that fails, then it's time to give up and just return
                    }
                    -1
                }
            }
            4 -> {
                // Call the method, write to outBuf and return a status code
                // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs` for info
                try {
                    val buffer = this.`invokeIter`(cb, args)
                    // Success
                    outBuf.setValue(buffer)
                    1
                } catch (e: Throwable) {
                    // Unexpected error
                    try {
                        // Try to serialize the error into a string
                        outBuf.setValue(FfiConverterString.lower(e.toString()))
                    } catch (e: Throwable) {
                        // If that fails, then it's time to give up and just return
                    }
                    -1
                }
            }
            
            else -> {
                // An unexpected error happened.
                // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
                try {
                    // Try to serialize the error into a string
                    outBuf.setValue(FfiConverterString.lower("Invalid Callback index"))
                } catch (e: Throwable) {
                    // If that fails, then it's time to give up and just return
                }
                -1
            }
        }
    }

    
    private fun `invokeGet`(kotlinCallbackInterface: DbCollectionInterface, args: RustBuffer.ByValue): RustBuffer.ByValue =
        try {
            val buf = args.asByteBuffer() ?: throw InternalException("No ByteBuffer in RustBuffer; this is a Uniffi bug")
            kotlinCallbackInterface.`get`(
                    FfiConverterString.read(buf)
                    )
            .let {
                    FfiConverterOptionalSequenceUByte.lowerIntoRustBuffer(it)
                }// TODO catch errors and report them back to Rust.
                // https://github.com/mozilla/uniffi-rs/issues/351
        } finally {
            RustBuffer.free(args)
        }

    
    private fun `invokePut`(kotlinCallbackInterface: DbCollectionInterface, args: RustBuffer.ByValue): RustBuffer.ByValue =
        try {
            val buf = args.asByteBuffer() ?: throw InternalException("No ByteBuffer in RustBuffer; this is a Uniffi bug")
            kotlinCallbackInterface.`put`(
                    FfiConverterString.read(buf), 
                    FfiConverterSequenceUByte.read(buf)
                    )
            .let { RustBuffer.ByValue() }
                // TODO catch errors and report them back to Rust.
                // https://github.com/mozilla/uniffi-rs/issues/351
        } finally {
            RustBuffer.free(args)
        }

    
    private fun `invokeDel`(kotlinCallbackInterface: DbCollectionInterface, args: RustBuffer.ByValue): RustBuffer.ByValue =
        try {
            val buf = args.asByteBuffer() ?: throw InternalException("No ByteBuffer in RustBuffer; this is a Uniffi bug")
            kotlinCallbackInterface.`del`(
                    FfiConverterString.read(buf)
                    )
            .let { RustBuffer.ByValue() }
                // TODO catch errors and report them back to Rust.
                // https://github.com/mozilla/uniffi-rs/issues/351
        } finally {
            RustBuffer.free(args)
        }

    
    private fun `invokeIter`(kotlinCallbackInterface: DbCollectionInterface, args: RustBuffer.ByValue): RustBuffer.ByValue =
        try {
            val buf = args.asByteBuffer() ?: throw InternalException("No ByteBuffer in RustBuffer; this is a Uniffi bug")
            kotlinCallbackInterface.`iter`(
                    FfiConverterBoolean.read(buf), 
                    FfiConverterString.read(buf)
                    )
            .let {
                    FfiConverterTypeDbCollectionIteratorInterface.lowerIntoRustBuffer(it)
                }// TODO catch errors and report them back to Rust.
                // https://github.com/mozilla/uniffi-rs/issues/351
        } finally {
            RustBuffer.free(args)
        }

    
}

// The ffiConverter which transforms the Callbacks in to Handles to pass to Rust.
public object FfiConverterTypeDbCollectionInterface: FfiConverterCallbackInterface<DbCollectionInterface>(
    foreignCallback = ForeignCallbackTypeDbCollectionInterface()
) {
    override fun register(lib: _UniFFILib) {
        rustCall() { status ->
            lib.ffi_taple_ffi_b33d_DbCollectionInterface_init_callback(this.foreignCallback, status)
        }
    }
}






// Declaration and FfiConverters for DbCollectionIteratorInterface Callback Interface

public interface DbCollectionIteratorInterface {
    fun `next`(): Tuple?
    
}

// The ForeignCallback that is passed to Rust.
internal class ForeignCallbackTypeDbCollectionIteratorInterface : ForeignCallback {
    @Suppress("TooGenericExceptionCaught")
    override fun invoke(handle: Handle, method: Int, args: RustBuffer.ByValue, outBuf: RustBufferByReference): Int {
        val cb = FfiConverterTypeDbCollectionIteratorInterface.lift(handle)
        return when (method) {
            IDX_CALLBACK_FREE -> {
                FfiConverterTypeDbCollectionIteratorInterface.drop(handle)
                // No return value.
                // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
                0
            }
            1 -> {
                // Call the method, write to outBuf and return a status code
                // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs` for info
                try {
                    try {
                        val buffer = this.`invokeNext`(cb, args)
                        // Success
                        outBuf.setValue(buffer)
                        1
                    } catch (e: DbException) {
                        // Expected error
                        val buffer = FfiConverterTypeDbError.lowerIntoRustBuffer(e)
                        outBuf.setValue(buffer)
                        -2
                    }
                } catch (e: Throwable) {
                    // Unexpected error
                    try {
                        // Try to serialize the error into a string
                        outBuf.setValue(FfiConverterString.lower(e.toString()))
                    } catch (e: Throwable) {
                        // If that fails, then it's time to give up and just return
                    }
                    -1
                }
            }
            
            else -> {
                // An unexpected error happened.
                // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
                try {
                    // Try to serialize the error into a string
                    outBuf.setValue(FfiConverterString.lower("Invalid Callback index"))
                } catch (e: Throwable) {
                    // If that fails, then it's time to give up and just return
                }
                -1
            }
        }
    }

    
    private fun `invokeNext`(kotlinCallbackInterface: DbCollectionIteratorInterface, args: RustBuffer.ByValue): RustBuffer.ByValue =
        try {
            kotlinCallbackInterface.`next`()
            .let {
                    FfiConverterOptionalTypeTuple.lowerIntoRustBuffer(it)
                }// TODO catch errors and report them back to Rust.
                // https://github.com/mozilla/uniffi-rs/issues/351
        } finally {
            RustBuffer.free(args)
        }

    
}

// The ffiConverter which transforms the Callbacks in to Handles to pass to Rust.
public object FfiConverterTypeDbCollectionIteratorInterface: FfiConverterCallbackInterface<DbCollectionIteratorInterface>(
    foreignCallback = ForeignCallbackTypeDbCollectionIteratorInterface()
) {
    override fun register(lib: _UniFFILib) {
        rustCall() { status ->
            lib.ffi_taple_ffi_b33d_DbCollectionIteratorInterface_init_callback(this.foreignCallback, status)
        }
    }
}






// Declaration and FfiConverters for NotificationHandlerInterface Callback Interface

public interface NotificationHandlerInterface {
    fun `processNotification`(`notification`: TapleNotification)
    
}

// The ForeignCallback that is passed to Rust.
internal class ForeignCallbackTypeNotificationHandlerInterface : ForeignCallback {
    @Suppress("TooGenericExceptionCaught")
    override fun invoke(handle: Handle, method: Int, args: RustBuffer.ByValue, outBuf: RustBufferByReference): Int {
        val cb = FfiConverterTypeNotificationHandlerInterface.lift(handle)
        return when (method) {
            IDX_CALLBACK_FREE -> {
                FfiConverterTypeNotificationHandlerInterface.drop(handle)
                // No return value.
                // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
                0
            }
            1 -> {
                // Call the method, write to outBuf and return a status code
                // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs` for info
                try {
                    val buffer = this.`invokeProcessNotification`(cb, args)
                    // Success
                    outBuf.setValue(buffer)
                    1
                } catch (e: Throwable) {
                    // Unexpected error
                    try {
                        // Try to serialize the error into a string
                        outBuf.setValue(FfiConverterString.lower(e.toString()))
                    } catch (e: Throwable) {
                        // If that fails, then it's time to give up and just return
                    }
                    -1
                }
            }
            
            else -> {
                // An unexpected error happened.
                // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
                try {
                    // Try to serialize the error into a string
                    outBuf.setValue(FfiConverterString.lower("Invalid Callback index"))
                } catch (e: Throwable) {
                    // If that fails, then it's time to give up and just return
                }
                -1
            }
        }
    }

    
    private fun `invokeProcessNotification`(kotlinCallbackInterface: NotificationHandlerInterface, args: RustBuffer.ByValue): RustBuffer.ByValue =
        try {
            val buf = args.asByteBuffer() ?: throw InternalException("No ByteBuffer in RustBuffer; this is a Uniffi bug")
            kotlinCallbackInterface.`processNotification`(
                    FfiConverterTypeTapleNotification.read(buf)
                    )
            .let { RustBuffer.ByValue() }
                // TODO catch errors and report them back to Rust.
                // https://github.com/mozilla/uniffi-rs/issues/351
        } finally {
            RustBuffer.free(args)
        }

    
}

// The ffiConverter which transforms the Callbacks in to Handles to pass to Rust.
public object FfiConverterTypeNotificationHandlerInterface: FfiConverterCallbackInterface<NotificationHandlerInterface>(
    foreignCallback = ForeignCallbackTypeNotificationHandlerInterface()
) {
    override fun register(lib: _UniFFILib) {
        rustCall() { status ->
            lib.ffi_taple_ffi_b33d_NotificationHandlerInterface_init_callback(this.foreignCallback, status)
        }
    }
}




public object FfiConverterOptionalULong: FfiConverterRustBuffer<ULong?> {
    override fun read(buf: ByteBuffer): ULong? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterULong.read(buf)
    }

    override fun allocationSize(value: ULong?): Int {
        if (value == null) {
            return 1
        } else {
            return 1 + FfiConverterULong.allocationSize(value)
        }
    }

    override fun write(value: ULong?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterULong.write(value, buf)
        }
    }
}




public object FfiConverterOptionalLong: FfiConverterRustBuffer<Long?> {
    override fun read(buf: ByteBuffer): Long? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterLong.read(buf)
    }

    override fun allocationSize(value: Long?): Int {
        if (value == null) {
            return 1
        } else {
            return 1 + FfiConverterLong.allocationSize(value)
        }
    }

    override fun write(value: Long?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterLong.write(value, buf)
        }
    }
}




public object FfiConverterOptionalBoolean: FfiConverterRustBuffer<Boolean?> {
    override fun read(buf: ByteBuffer): Boolean? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterBoolean.read(buf)
    }

    override fun allocationSize(value: Boolean?): Int {
        if (value == null) {
            return 1
        } else {
            return 1 + FfiConverterBoolean.allocationSize(value)
        }
    }

    override fun write(value: Boolean?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterBoolean.write(value, buf)
        }
    }
}




public object FfiConverterOptionalString: FfiConverterRustBuffer<String?> {
    override fun read(buf: ByteBuffer): String? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterString.read(buf)
    }

    override fun allocationSize(value: String?): Int {
        if (value == null) {
            return 1
        } else {
            return 1 + FfiConverterString.allocationSize(value)
        }
    }

    override fun write(value: String?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterString.write(value, buf)
        }
    }
}




public object FfiConverterOptionalTypeUserGovernance: FfiConverterRustBuffer<UserGovernance?> {
    override fun read(buf: ByteBuffer): UserGovernance? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeUserGovernance.read(buf)
    }

    override fun allocationSize(value: UserGovernance?): Int {
        if (value == null) {
            return 1
        } else {
            return 1 + FfiConverterTypeUserGovernance.allocationSize(value)
        }
    }

    override fun write(value: UserGovernance?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeUserGovernance.write(value, buf)
        }
    }
}




public object FfiConverterOptionalTypeTapleSignedApprovalResponse: FfiConverterRustBuffer<TapleSignedApprovalResponse?> {
    override fun read(buf: ByteBuffer): TapleSignedApprovalResponse? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeTapleSignedApprovalResponse.read(buf)
    }

    override fun allocationSize(value: TapleSignedApprovalResponse?): Int {
        if (value == null) {
            return 1
        } else {
            return 1 + FfiConverterTypeTapleSignedApprovalResponse.allocationSize(value)
        }
    }

    override fun write(value: TapleSignedApprovalResponse?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeTapleSignedApprovalResponse.write(value, buf)
        }
    }
}




public object FfiConverterOptionalTypeTuple: FfiConverterRustBuffer<Tuple?> {
    override fun read(buf: ByteBuffer): Tuple? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeTuple.read(buf)
    }

    override fun allocationSize(value: Tuple?): Int {
        if (value == null) {
            return 1
        } else {
            return 1 + FfiConverterTypeTuple.allocationSize(value)
        }
    }

    override fun write(value: Tuple?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeTuple.write(value, buf)
        }
    }
}




public object FfiConverterOptionalSequenceUByte: FfiConverterRustBuffer<List<UByte>?> {
    override fun read(buf: ByteBuffer): List<UByte>? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterSequenceUByte.read(buf)
    }

    override fun allocationSize(value: List<UByte>?): Int {
        if (value == null) {
            return 1
        } else {
            return 1 + FfiConverterSequenceUByte.allocationSize(value)
        }
    }

    override fun write(value: List<UByte>?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterSequenceUByte.write(value, buf)
        }
    }
}




public object FfiConverterSequenceUByte: FfiConverterRustBuffer<List<UByte>> {
    override fun read(buf: ByteBuffer): List<UByte> {
        val len = buf.getInt()
        return List<UByte>(len) {
            FfiConverterUByte.read(buf)
        }
    }

    override fun allocationSize(value: List<UByte>): Int {
        val sizeForLength = 4
        val sizeForItems = value.map { FfiConverterUByte.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<UByte>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.forEach {
            FfiConverterUByte.write(it, buf)
        }
    }
}




public object FfiConverterSequenceString: FfiConverterRustBuffer<List<String>> {
    override fun read(buf: ByteBuffer): List<String> {
        val len = buf.getInt()
        return List<String>(len) {
            FfiConverterString.read(buf)
        }
    }

    override fun allocationSize(value: List<String>): Int {
        val sizeForLength = 4
        val sizeForItems = value.map { FfiConverterString.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<String>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.forEach {
            FfiConverterString.write(it, buf)
        }
    }
}




public object FfiConverterSequenceTypeUserSubject: FfiConverterRustBuffer<List<UserSubject>> {
    override fun read(buf: ByteBuffer): List<UserSubject> {
        val len = buf.getInt()
        return List<UserSubject>(len) {
            FfiConverterTypeUserSubject.read(buf)
        }
    }

    override fun allocationSize(value: List<UserSubject>): Int {
        val sizeForLength = 4
        val sizeForItems = value.map { FfiConverterTypeUserSubject.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<UserSubject>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.forEach {
            FfiConverterTypeUserSubject.write(it, buf)
        }
    }
}




public object FfiConverterSequenceTypePolicy: FfiConverterRustBuffer<List<Policy>> {
    override fun read(buf: ByteBuffer): List<Policy> {
        val len = buf.getInt()
        return List<Policy>(len) {
            FfiConverterTypePolicy.read(buf)
        }
    }

    override fun allocationSize(value: List<Policy>): Int {
        val sizeForLength = 4
        val sizeForItems = value.map { FfiConverterTypePolicy.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<Policy>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.forEach {
            FfiConverterTypePolicy.write(it, buf)
        }
    }
}




public object FfiConverterSequenceTypeRole: FfiConverterRustBuffer<List<Role>> {
    override fun read(buf: ByteBuffer): List<Role> {
        val len = buf.getInt()
        return List<Role>(len) {
            FfiConverterTypeRole.read(buf)
        }
    }

    override fun allocationSize(value: List<Role>): Int {
        val sizeForLength = 4
        val sizeForItems = value.map { FfiConverterTypeRole.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<Role>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.forEach {
            FfiConverterTypeRole.write(it, buf)
        }
    }
}




public object FfiConverterSequenceTypeSchema: FfiConverterRustBuffer<List<Schema>> {
    override fun read(buf: ByteBuffer): List<Schema> {
        val len = buf.getInt()
        return List<Schema>(len) {
            FfiConverterTypeSchema.read(buf)
        }
    }

    override fun allocationSize(value: List<Schema>): Int {
        val sizeForLength = 4
        val sizeForItems = value.map { FfiConverterTypeSchema.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<Schema>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.forEach {
            FfiConverterTypeSchema.write(it, buf)
        }
    }
}




public object FfiConverterSequenceTypeSubjectAndProviders: FfiConverterRustBuffer<List<SubjectAndProviders>> {
    override fun read(buf: ByteBuffer): List<SubjectAndProviders> {
        val len = buf.getInt()
        return List<SubjectAndProviders>(len) {
            FfiConverterTypeSubjectAndProviders.read(buf)
        }
    }

    override fun allocationSize(value: List<SubjectAndProviders>): Int {
        val sizeForLength = 4
        val sizeForItems = value.map { FfiConverterTypeSubjectAndProviders.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<SubjectAndProviders>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.forEach {
            FfiConverterTypeSubjectAndProviders.write(it, buf)
        }
    }
}




public object FfiConverterSequenceTypeTapleSignature: FfiConverterRustBuffer<List<TapleSignature>> {
    override fun read(buf: ByteBuffer): List<TapleSignature> {
        val len = buf.getInt()
        return List<TapleSignature>(len) {
            FfiConverterTypeTapleSignature.read(buf)
        }
    }

    override fun allocationSize(value: List<TapleSignature>): Int {
        val sizeForLength = 4
        val sizeForItems = value.map { FfiConverterTypeTapleSignature.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<TapleSignature>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.forEach {
            FfiConverterTypeTapleSignature.write(it, buf)
        }
    }
}




public object FfiConverterSequenceTypeTapleSignedEvent: FfiConverterRustBuffer<List<TapleSignedEvent>> {
    override fun read(buf: ByteBuffer): List<TapleSignedEvent> {
        val len = buf.getInt()
        return List<TapleSignedEvent>(len) {
            FfiConverterTypeTapleSignedEvent.read(buf)
        }
    }

    override fun allocationSize(value: List<TapleSignedEvent>): Int {
        val sizeForLength = 4
        val sizeForItems = value.map { FfiConverterTypeTapleSignedEvent.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<TapleSignedEvent>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.forEach {
            FfiConverterTypeTapleSignedEvent.write(it, buf)
        }
    }
}



public object FfiConverterMapStringTapleSignature: FfiConverterRustBuffer<Map<String, TapleSignature>> {
    override fun read(buf: ByteBuffer): Map<String, TapleSignature> {
        // TODO: Once Kotlin's `buildMap` API is stabilized we should use it here.
        val items : MutableMap<String, TapleSignature> = mutableMapOf()
        val len = buf.getInt()
        repeat(len) {
            val k = FfiConverterString.read(buf)
            val v = FfiConverterTypeTapleSignature.read(buf)
            items[k] = v
        }
        return items
    }

    override fun allocationSize(value: Map<String, TapleSignature>): Int {
        val spaceForMapSize = 4
        val spaceForChildren = value.map { (k, v) ->
            FfiConverterString.allocationSize(k) +
            FfiConverterTypeTapleSignature.allocationSize(v)
        }.sum()
        return spaceForMapSize + spaceForChildren
    }

    override fun write(value: Map<String, TapleSignature>, buf: ByteBuffer) {
        buf.putInt(value.size)
        // The parens on `(k, v)` here ensure we're calling the right method,
        // which is important for compatibility with older android devices.
        // Ref https://blog.danlew.net/2017/03/16/kotlin-puzzler-whose-line-is-it-anyways/
        value.forEach { (k, v) ->
            FfiConverterString.write(k, buf)
            FfiConverterTypeTapleSignature.write(v, buf)
        }
    }
}
@Throws(InitializationException::class)

fun `start`(`manager`: DatabaseManagerInterface, `settings`: TapleSettings): TapleNode {
    return FfiConverterTypeTapleNode.lift(
    rustCallWithError(InitializationException) { _status ->
    _UniFFILib.INSTANCE.taple_ffi_b33d_start(FfiConverterTypeDatabaseManagerInterface.lower(`manager`), FfiConverterTypeTapleSettings.lower(`settings`), _status)
})
}



fun `generateKey`(`keyDerivator`: TapleKeyDerivator): List<UByte> {
    return FfiConverterSequenceUByte.lift(
    rustCall() { _status ->
    _UniFFILib.INSTANCE.taple_ffi_b33d_generate_key(FfiConverterTypeTapleKeyDerivator.lower(`keyDerivator`), _status)
})
}




